<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>XROBO BLE</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://unpkg.com/blockly/blockly.min.js"></script>
<style>
  :root{
    --pad:10px;
    --uiScale: 1;
    --headerH: 64px;
    --btnH: 36px;
    --gap: 8px;
    --headerBgTop: #fff7ed;
    --headerBgBottom: #fffbeb;
    --headerBorder: #fed7aa;
    --logH: 180px;
    --blue: #1d4ed8;

    /* í•¸ë“¤/ì‚¼ê°í˜• */
    --handleWBase: 22;
    --handleHBase: 28;
    --triWBase:   14;
    --triHBase:   12;

    --handleW: calc(var(--handleWBase) * var(--uiScale) * 1px);
    --handleH: calc(var(--handleHBase) * var(--uiScale) * 1px);
    --triW:    calc(var(--triWBase)    * var(--uiScale) * 1px);
    --triH:    calc(var(--triHBase)    * var(--uiScale) * 1px);
    --linkBar: calc(3 * var(--uiScale) * 1px);

    /* ê±´ë°˜ ê¸°ë³¸ê°’(ìë°”ìŠ¤í¬ë¦½íŠ¸ ìë™ë§ì¶¤ì´ ì£¼ë¡œ ì‚¬ìš©ë¨) */
    --keyW: clamp(52px, 8vmin, 92px);
    --keyH: calc(var(--keyW) * 2.7);
    --keyGap: 6px;
    --keyFont: 14px;
  }
  @media (max-width: 480px){
    :root{ --keyGap: 4px; --keyFont: 13px; }
  }

  *{ box-sizing:border-box; }
  html, body{ height:100%; }
  body{ margin:0; font-family:system-ui, sans-serif; background:#fff; }

  /* â”€â”€ í—¤ë” â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  header{
    padding: 8px 12px;
    background: linear-gradient(180deg, var(--headerBgTop), var(--headerBgBottom));
    border-bottom: 1px solid var(--headerBorder);
    position:relative; z-index:10;
  }
  #topbar{
    display:flex; align-items:center; gap: calc(var(--gap) * var(--uiScale));
    flex-wrap: wrap;
  }
  .title{
    font-weight: 800; letter-spacing: .2px;
    color:#7c2d12; margin-right: 12px;
    font-size: calc(18px * var(--uiScale));
  }
  .spacer{ flex: 1 1 auto; }

  .btn{
    height: calc(var(--btnH) * var(--uiScale));
    padding: 0 calc(12px * var(--uiScale));
    border:0; border-radius: calc(10px * var(--uiScale));
    display:inline-flex; align-items:center; justify-content:center;
    font-size: calc(14px * var(--uiScale)); font-weight:600;
    box-shadow:0 2px 8px rgba(0,0,0,.08);
    background:#f3f4f6; color:#111827; cursor:pointer;
    user-select:none;
  }
  .btn.small{ /* â˜… ë³€ê²½: ì¹´ë©”ë¼ ì°½ ì•ˆì˜ ì†Œí˜• ë²„íŠ¼ */
    height: calc(var(--btnH) * var(--uiScale) * .85);
    padding: 0 calc(10px * var(--uiScale));
    font-size: calc(12px * var(--uiScale));
  }
  #connectToggle{ background:#2563eb; color:#fff; }
  #runToggle{ background:#16a34a; color:#fff; }
  #fsBtn{ background:#111827; color:#fff; }

  .state{
    display:inline-flex; align-items:center; gap:calc(6px * var(--uiScale));
    height: calc(var(--btnH) * var(--uiScale));
    padding: 0 calc(6px * var(--uiScale));
    font-size: calc(12px * var(--uiScale));
  }
  .badgeDot{
    width: calc(22px * var(--uiScale));
    height: calc(22px * var(--uiScale));
    border-radius: 50%;
    display:inline-flex; align-items:center; justify-content:center;
    font-size: calc(11px * var(--uiScale));
    font-weight:800; color:#fff;
    box-shadow: 0 0 0 calc(4px * var(--uiScale)) rgba(0,0,0,.06) inset;
  }
  .badgeDot.on{ background:#3b82f6; }
  .badgeDot.off{ background:#ef4444; }

  /* â”€â”€ ë ˆì´ì•„ì›ƒ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #main{ display:flex; width:100%; height: calc(100vh - var(--headerH)); }
  #left{ position:relative; flex:1 1 auto; min-width:0; height:100%; display:flex; overflow:visible; }
  #blocklyDiv{ flex:1 1 auto; min-width:0; height:100%; width:100%; }

  #right{
    flex:0 0 40%; display:flex; flex-direction:column; background:#fff;
    margin:8px 8px 8px 0; border:1px solid #e5e7eb; border-left:3px solid var(--blue);
    border-radius:12px 0 0 12px; box-shadow:0 2px 10px rgba(0,0,0,.04); overflow:hidden;
    position:relative;
  }

  /* â”€â”€ ìš°ì¸¡ ìƒë‹¨: ì¹´ë©”ë¼ í”„ë¦¬ë·° ì˜ì—­ (í”¼ì•„ë…¸ â†’ ì¹´ë©”ë¼) â”€â”€ */
  #rightTop{
    flex:1 1 auto; border-bottom:1px solid #e5e7eb; min-height: 120px;
    background:#0b0f14; color:#fff;
    display:flex; align-items:center; justify-content:center;
    padding: 0;
    overflow:hidden;
  }
  /* â˜… ë³€ê²½: ì¹´ë©”ë¼ í”„ë¦¬ë·° ë˜í¼/ë²„íŠ¼ */
  .camWrap{
    position:relative; width:100%; height:100%;
    display:flex; align-items:center; justify-content:center;
    background:#000;
  }
  #camVideo{
    width:100%; height:100%; object-fit:cover; transform: scaleX(-1); /* ì „ë©´ ì¹´ë©”ë¼ ê±°ìš¸ íš¨ê³¼ */
    background:#000;
  }
  .camUi{
    position:absolute; right:12px; top:12px; display:flex; gap:8px; align-items:center;
    z-index:2;
  }
  .camBadge{
    font: 700 12px/1 system-ui; color:#fff;
    padding:.35rem .6rem; border-radius:999px; border:1px solid rgba(255,255,255,.3);
    background:rgba(0,0,0,.35); backdrop-filter: blur(6px);
  }

  /* ë¦¬ì‚¬ì´ì € ë°” */
  #rightDivider{
    flex:0 0 6px; cursor: row-resize;
    background: repeating-linear-gradient(90deg, #d1d5db 0, #d1d5db 6px, #e5e7eb 6px, #e5e7eb 12px);
  }

  /* ë¡œê·¸ íŒ¨ë„ */
  #rightBottom{
    flex: 0 0 var(--logH);
    display:flex; flex-direction:column; min-height:0; overflow:hidden;
    padding: calc(10px * var(--uiScale));
    background:#0b0f14; color:#d1e4ff; border-top:1px solid #1f2937;
  }
  #log{
    flex:1 1 0; min-height:0; overflow:auto; white-space:pre-wrap;
    background:#0b0f14; border:1px solid #1f2937; border-radius: calc(8px * var(--uiScale));
    padding: calc(10px * var(--uiScale));
    font-family: ui-monospace, Menlo, Consolas, monospace;
    font-size: calc(12px * var(--uiScale)); color:#d1e4ff;
  }

  /* ì‹¤í–‰ì°½ í† ê¸€ í•¸ë“¤ */
  #panelHandle{
    position:absolute; top: calc(12px * var(--uiScale)); right: 0;
    z-index:9999; width: var(--handleW); height: var(--handleH);
    background: var(--blue); border: 0; border-radius: calc(6px * var(--uiScale));
    box-shadow: 0 2px 8px rgba(0,0,0,.18);
    cursor: pointer; padding: 0;
  }
  #panelHandle::before{
    content:''; position:absolute; top:0; right: calc(0px - var(--linkBar));
    width: var(--linkBar); height:100%; background: var(--blue);
    border-top-right-radius: calc(6px * var(--uiScale));
    border-bottom-right-radius: calc(6px * var(--uiScale));
  }
  #panelHandle::after{
    content:''; position:absolute; top:50%; transform: translateY(-50%);
    width:0; height:0; border-style: solid;
  }
  #panelHandle.open::after{
    left: calc((var(--handleW) - var(--triW)) / 2);
    border-width: var(--triH) 0 var(--triH) var(--triW);
    border-color: transparent transparent transparent white;
  }
  #panelHandle.closed::after{
    left: calc((var(--handleW) - var(--triW)) / 2);
    border-width: var(--triH) var(--triW) var(--triH) 0;
    border-color: transparent white transparent transparent;
  }
  .blocklyZoom,.blocklyTrash{ display:block !important; }
  .blocklyTrashLid, .blocklyTrashcanLid, .blocklyTrashCanLid { display:none !important; }

  body.fs-active #main{ height: calc(100vh - var(--headerH)); }
  body.panel-collapsed #right{ display:none; }
  body.panel-collapsed #left{ flex:1 1 100%; }

  /* â”€â”€ ì‹¤í–‰ìš© ì „ì²´í™”ë©´ ì˜¤ë²„ë ˆì´(ê¸°ì¡´ ê·¸ëŒ€ë¡œ) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #playOverlay{
    position:fixed; inset:0; background:#0b0f14; color:#fff;
    display:none; flex-direction:column; z-index:10000;
  }
  #playOverlay.show{ display:flex; }
  #playOverlay .topbar{
    height:56px; display:flex; align-items:center; justify-content:flex-end;
    padding: 10px 14px; border-bottom:1px solid #1f2937; background:#0b0f14;
  }
  #playOverlay .body{
    flex:1 1 auto; display:flex; align-items:center; justify-content:center; overflow:auto;
    padding: 20px;
  }
  #overlayClose{
    background:#ef4444; color:#fff; border:0; border-radius:10px; padding:10px 16px; font-weight:800; cursor:pointer;
    box-shadow:0 2px 8px rgba(0,0,0,.2);
  }
</style>
</head>
<body>
  <!-- í—¤ë” -->
  <header id="appHeader">
    <div id="topbar">
      <div class="title">XROBO BLE</div>
      <div class="spacer"></div>

      <button id="saveBtn" class="btn" title="í”„ë¡œì íŠ¸ ì €ì¥">ì €ì¥</button>
      <button id="openBtn" class="btn" title="í”„ë¡œì íŠ¸ ë¶ˆëŸ¬ì˜¤ê¸°">ë¶ˆëŸ¬ì˜¤ê¸°</button>

      <span class="state"><span id="statusDot" class="badgeDot off">off</span></span>
      <button id="connectToggle" class="btn">ì—°ê²°</button>
      <button id="runToggle" class="btn">â–¶ ì‹¤í–‰</button> <!-- â˜… ë³€ê²½: BLE ë¯¸ì—°ë™ í—ˆìš© -->
      <button id="fsBtn" class="btn" title="ì „ì²´í™”ë©´">ì „ì²´í™”ë©´</button>
    </div>
  </header>

  <!-- ë³¸ë¬¸ -->
  <div id="main">
    <div id="left">
      <div id="blocklyDiv"></div>
      <button id="panelHandle" class="open" title="ì‹¤í–‰ì°½ ë‹«ê¸°"></button>
    </div>

    <div id="right">
      <!-- ì˜¤ë¥¸ìª½ ìƒë‹¨: â˜… ë³€ê²½(í”¼ì•„ë…¸ â†’ ì¹´ë©”ë¼) -->
      <div id="rightTop">
        <div class="camWrap">
          <video id="camVideo" playsinline autoplay muted></video>
          <div class="camUi">
            <span id="camBadge" class="camBadge">Cam: off</span>
            <button id="camToggle" class="btn small">ìº  ì¼œê¸°</button>
          </div>
        </div>
      </div>
      <div id="rightDivider" title="ë“œë˜ê·¸í•˜ì—¬ ë¡œê·¸ ë†’ì´ ì¡°ì ˆ"></div>
      <div id="rightBottom">
        <div style="font-size:calc(12px * var(--uiScale));color:#9ca3af;">ì‹¤í–‰ ë¡œê·¸</div>
        <div id="log"></div>
      </div>
    </div>
  </div>

  <!-- íˆ´ë°•ìŠ¤ -->
  <xml id="toolbox" style="display:none">
    <category name="ì´ë²¤íŠ¸" colour="#f59e0b">
      <!-- â˜… ë³€ê²½: 'ë„ë¥¼ ëˆ„ë¥´ë©´' â†’ 'ë¹¨ê°„ìƒ‰ì´ ë³´ì´ë©´' -->
      <block type="xrobo_start"></block>
    </category>

    <category name="ì¶œë ¥" colour="#60a5fa">
      <block type="motor12_dd">
        <field name="M1">20</field><field name="M2">20</field><field name="MS">500</field>
      </block>
      <block type="motor12_in">
        <value name="M1"><shadow type="math_number"><field name="NUM">20</field></shadow></value>
        <value name="M2"><shadow type="math_number"><field name="NUM">20</field></shadow></value>
        <value name="MS"><shadow type="math_number"><field name="NUM">500</field></shadow></value>
      </block>
      <block type="melody">
        <field name="PITCH">C4</field>
        <value name="DUR"><shadow type="math_number"><field name="NUM">200</field></shadow></value>
        <value name="WAIT"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
      </block>
      <block type="led_ctrl">
        <field name="TGT">OUT1</field>
        <field name="MODE">BRIGHT</field>
        <field name="VAL">10</field>
      </block>
    </category>

    <category name="ì œì–´" colour="#10b981">
      <block type="controls_repeat_ext">
        <value name="TIMES"><shadow type="math_number"><field name="NUM">3</field></shadow></value>
      </block>
      <block type="wait_seconds">
        <value name="SEC"><shadow type="math_number"><field name="NUM">1</field></shadow></value>
      </block>
    </category>
  </xml>

  <!-- ì‹¤í–‰ìš© ì „ì²´í™”ë©´ ì˜¤ë²„ë ˆì´ -->
  <div id="playOverlay" aria-hidden="true">
    <div class="topbar"><button id="overlayClose">ì¢…ë£Œ</button></div>
    <div class="body"><!-- í•„ìš”ì‹œ ì „ì²´í™”ë©´ ì „ìš© UI ë°°ì¹˜ ê°€ëŠ¥ --></div>
  </div>

<script>
/* ================= Blockly ê¸°ë³¸ ì„¤ì • ================= */
class XroboZelosProvider extends Blockly.zelos.ConstantProvider {
  constructor(){ super(); this.ADD_START_HATS = true; }
}
class XroboZelosRenderer extends Blockly.zelos.Renderer {
  constructor(){ super('xrobo_zelos'); }
  makeConstants_(){ return new XroboZelosProvider(); }
}
Blockly.blockRendering.register('xrobo_zelos', XroboZelosRenderer);

const XroboTheme = Blockly.Theme.defineTheme('xrobo_theme', {
  base: Blockly.Themes.Zelos, componentStyles: { startHats: true }
});

var ws = Blockly.inject('blocklyDiv', {
  toolbox: document.getElementById('toolbox'),
  renderer: 'xrobo_zelos',
  theme: XroboTheme,
  grid: { spacing:20, length:3, colour:'#eee', snap:true },
  zoom: { controls:true, wheel:true, startScale:1, minScale:0.5, maxScale:2 },
  move: { scrollbars:true, drag:true, wheel:true },
  trashcan: true
});

/* â–¼â–¼â–¼ Blockly v12 ë³€ìˆ˜ API ê²½ê³  ì œê±°ìš© SHIM â–¼â–¼â–¼ */
(function patchBlocklyDeprecated(){
  try{
    if (Blockly.Workspace &&
        Blockly.Workspace.prototype &&
        Blockly.Workspace.prototype.getAllVariables) {
      Blockly.Workspace.prototype.getAllVariables = function(){
        var vm = this.getVariableMap ? this.getVariableMap() : null;
        return (vm && vm.getAllVariables) ? vm.getAllVariables() : [];
      };
    }
  }catch(e){}
})();
/* â–²â–²â–² SHIM ë â–²â–²â–² */

/* ë“œë˜ê·¸ ì¤‘ ìë™ ìŠ¤í¬ë¡¤ ë°©ì§€ */
(function disableAutoScrollWhileBlockDragging(){
  try{
    if (Blockly.BlockDragger && Blockly.BlockDragger.prototype) {
      var orig = Blockly.BlockDragger.prototype.updateDrag;
      if (typeof orig === 'function') {
        Blockly.BlockDragger.prototype.updateDrag = function(e){
          var saved = this.autoScroll_;
          this.autoScroll_ = null;
          var r = orig.call(this, e);
          this.autoScroll_ = saved;
          return r;
        };
      }
    }
  }catch(e){ console.warn('AutoScroll patch failed', e); }
})();

/* ================= ìƒìˆ˜/ê³µìš© ================= */
var PINS_OUT=[["OUT1","OUT1"],["OUT2","OUT2"],["OUT3","OUT3"],["OUT4","OUT4"],["OUT5","OUT5"],["OUT6","OUT6"],["OUT7","OUT7"],["OUT8","OUT8"]];
var SPEEDS=Array.from({length:41},(_,i)=>20-i).map(v=>[String(v),String(v)]);
var TIMES100=Array.from({length:10},(_,i)=>100*(i+1)).map(v=>[String(v),String(v)]);
var LED_TGT=[].concat(PINS_OUT,[["CPU","CPU"]]);
var LED_MODE=[["ë°ê¸°","BRIGHT"],["ìˆ¨ì‰¬ê¸°","BREATHE"]];
var LED_VALS=Array.from({length:20},(_,i)=>[String(i),String(i)]);

/* ================= ë¸”ë¡ ì •ì˜ ================= */
/* â˜… ë³€ê²½: ì´ë²¤íŠ¸ ë¸”ë¡ì„ â€œë¹¨ê°„ìƒ‰ì´ ë³´ì´ë©´â€ìœ¼ë¡œ êµì²´(ë“œë¡­ë‹¤ìš´ ì œê±°) */
Blockly.defineBlocksWithJsonArray([
  {
    "type":"xrobo_start",
    "message0":"ë¹¨ê°„ìƒ‰ì´ ë³´ì´ë©´",
    "nextStatement":null,
    "colour":36,
    "hat":"cap"
  },
  { "type":"motor12_dd","message0":"ëª¨í„° M1 %1  M2 %2  ì‹œê°„ %3 ms",
    "args0":[{"type":"field_dropdown","name":"M1","options":SPEEDS},{"type":"field_dropdown","name":"M2","options":SPEEDS},{"type":"field_dropdown","name":"MS","options":TIMES100}],
    "previousStatement":null,"nextStatement":null,"inputsInline":true,"colour":210 },
  { "type":"motor12_in","message0":"ëª¨í„° M1 %1  M2 %2  ì‹œê°„ %3 ms",
    "args0":[{"type":"input_value","name":"M1","check":"Number"},{"type":"input_value","name":"M2","check":"Number"},{"type":"input_value","name":"MS","check":"Number"}],
    "previousStatement":null,"nextStatement":null,"inputsInline":true,"colour":210 },
  { "type":"melody","message0":"ë©œë¡œë”” ìŒë†’ì´ %1 ì†Œë¦¬ì‹œê°„ %2 ms ëŒ€ê¸°ì‹œê°„ %3 ms",
    "args0":[{"type":"field_dropdown","name":"PITCH","options":(function(){var KR=["ë„","ë ˆ","ë¯¸","íŒŒ","ì†”","ë¼","ì‹œ"], EN=["C","D","E","F","G","A","B"], L=[]; for(var o=4;o<=6;o++) for(var i=0;i<7;i++) L.push([KR[i]+o, EN[i]+o]); return L;})()},
             {"type":"input_value","name":"DUR","check":"Number"},{"type":"input_value","name":"WAIT","check":"Number"}],
    "previousStatement":null,"nextStatement":null,"inputsInline":true,"colour":300 },
  { "type":"led_ctrl","message0":"LED %1 ëª¨ë“œ %2 ê°’ %3",
    "args0":[{"type":"field_dropdown","name":"TGT","options":LED_TGT},{"type":"field_dropdown","name":"MODE","options":LED_MODE},{"type":"field_dropdown","name":"VAL","options":LED_VALS}],
    "previousStatement":null,"nextStatement":null,"inputsInline":true,"colour":330 },
  { "type":"wait_seconds","message0":"%1 ì´ˆ ê¸°ë‹¤ë¦¬ê¸°",
    "args0":[{"type":"input_value","name":"SEC","check":"Number"}],
    "previousStatement":null,"nextStatement":null,"inputsInline":true,"colour":120 }
]);

/* ================= ì½”ë“œ ë¹Œë” ================= */
function numFromInput(parent, name, def){ if (def===void 0) def=0;
  var raw = Blockly.JavaScript.valueToCode(parent, name, Blockly.JavaScript.ORDER_NONE);
  var n = Number(raw != null ? raw : ''); return (isFinite(n) ? n : def);
}
function walkNode(b, list){
  if(!b) return;
  switch(b.type){
    case 'motor12_dd':{
      var v1=+b.getFieldValue('M1'),v2=+b.getFieldValue('M2'),ms=+b.getFieldValue('MS');
      list.push({type:'CMD',s:'M12 '+v1+' '+v2+' '+ms}); if(ms>0) list.push({type:'W',args:[ms]}); break; }
    case 'motor12_in':{
      var v1n=numFromInput(b,'M1',0),v2n=numFromInput(b,'M2',0),msn=numFromInput(b,'MS',0);
      list.push({type:'CMD',s:'M12 '+Math.round(v1n)+' '+Math.round(v2n)+' '+Math.round(msn)}); if(msn>0) list.push({type:'W',args:[msn]}); break; }
    case 'melody':{
      var p=b.getFieldValue('PITCH'),dur=numFromInput(b,'DUR',200),wait=numFromInput(b,'WAIT',0);
      list.push({type:'CMD',s:'MEL '+p+' '+Math.round(dur)+' '+Math.round(wait)}); if(wait>0) list.push({type:'W',args:[wait]}); break; }
    case 'led_ctrl':{
      var t=b.getFieldValue('TGT'),m=b.getFieldValue('MODE'),v=+b.getFieldValue('VAL');
      list.push({type:'CMD',s:'LED '+t+' '+m+' '+v}); break; }
    case 'controls_repeat_ext':{
      var times=Math.max(0, numFromInput(b,'TIMES',1));
      var inner=[]; var first=b.getInputTargetBlock('DO'); walkChain(first, inner);
      list.push({type:'FOR',count:times,body:inner}); break; }
    case 'wait_seconds':{
      var s=numFromInput(b,'SEC',1); if(s>0) list.push({type:'W',args:[s*1000]}); break; }
  }
}
function walkChain(start, list){ for(var n=start; n; n=n.getNextBlock()) walkNode(n, list); }
function normalizeProgram(list){
  var out=[]; for(var i=0;i<list.length;i++){
    var ins=list[i];
    if(ins.type==='CMD'){ var prev=out[out.length-1]; if(prev && prev.type==='CMD' && prev.s===ins.s) continue; }
    else if(ins.type==='W'){
      if(!isFinite(ins.args && ins.args[0]) || ins.args[0]<=0) continue;
      var prevw=out[out.length-1]; if(prevw && prevw.type==='W'){ prevw.args[0]+=ins.args[0]; continue; }
    }
    out.push(ins);
  }
  return out;
}

/* â˜… ë³€ê²½: 'ë¹¨ê°„ìƒ‰ì´ ë³´ì´ë©´' ì´ë²¤íŠ¸ìš© í”„ë¡œê·¸ë¨ ë¹Œë“œ */
function buildEventPrograms(){
  var evs = ws.getBlocksByType('xrobo_start', true);
  var seqAll=[];
  for(var i=0;i<evs.length;i++){
    var chain = evs[i].getNextBlock();
    if(!chain) continue;
    var prog=[]; walkChain(chain, prog);
    var norm = normalizeProgram(prog);
    Array.prototype.push.apply(seqAll, norm);
  }
  return { RED: seqAll }; // í•œ ì¢…ë¥˜ ì´ë²¤íŠ¸ë§Œ ì§€ì›(ë¹¨ê°„ìƒ‰)
}

/* ================= í—¤ë”/ìŠ¤ì¼€ì¼/í’€ìŠ¤í¬ë¦° ================= */
function applyHeaderHeight(){
  var px = document.getElementById('appHeader').offsetHeight || 64;
  document.documentElement.style.setProperty('--headerH', px+'px');
  setTimeout(function(){ Blockly.svgResize(ws); }, 60);
}
function applyUiScaleFromWorkspace(){
  var s = Math.max(.7, Math.min(1.6, ws.getScale()));
  document.documentElement.style.setProperty('--uiScale', s);
  applyHeaderHeight();
}
window.addEventListener('resize', applyHeaderHeight);
document.addEventListener('fullscreenchange', applyHeaderHeight);
ws.addChangeListener(function(ev){
  if(ev && ev.type===Blockly.Events.UI && ev.element==='zoom'){ applyUiScaleFromWorkspace(); }
});
setInterval(function(){ applyUiScaleFromWorkspace(); }, 200);
applyUiScaleFromWorkspace();
applyHeaderHeight();

/* ================= BLE & ë¡œê·¸(ê·¸ëŒ€ë¡œ, ì‹¤í–‰ì€ BLE ì—†ì´ë„ ì§„í–‰) ================= */
var SERVICE_UUID=0xFFF0;
var bleDevice=null,bleServer=null,bleService=null,writeChar=null,notifyChar=null;
var isConnected=false, isRunning=false;
var $=id=>document.getElementById(id);
var log=function(m){ var L=$('log'); L.textContent+=m+"\n"; L.scrollTop=L.scrollHeight; };
var dot=$('statusDot');
var btnConnect=$('connectToggle'), btnRun=$('runToggle');

var enc = s=> new TextEncoder().encode(s);

function resetBleRefs(){ bleDevice=null; bleServer=null; bleService=null; writeChar=null; notifyChar=null; }
function setConnected(v){
  isConnected=v;
  btnConnect.textContent=v?'í•´ì œ':'ì—°ê²°';
  btnRun.disabled=false; /* â˜… ë³€ê²½: BLE ì—†ì´ë„ ì‹¤í–‰ ê°€ëŠ¥ */
  dot.classList.toggle('on',v); dot.classList.toggle('off',!v);
  dot.textContent=v?'on':'off';
  if(!v) setRunning(false);
}
function setRunning(v){
  isRunning=v;
  btnRun.textContent=v?'â–  ì •ì§€':'â–¶ ì‹¤í–‰';
  btnRun.style.background = v ? '#ef4444' : '#16a34a';
  var ov=$('playOverlay');
  ov.classList.toggle('show', v);
  ov.setAttribute('aria-hidden', String(!v));
}

function connectBLE(){
  if(!navigator.bluetooth){ alert('ì´ ë¸Œë¼ìš°ì €ëŠ” Web Bluetooth ë¯¸ì§€ì›ì…ë‹ˆë‹¤.'); return; }
  (async function(){
    try{
      var dev = await navigator.bluetooth.requestDevice({
        filters:[{ namePrefix:'XROBO' }],
        optionalServices:[SERVICE_UUID, 0xFFF3, 0xFFF4]
      });
      try{ if (bleDevice && bleDevice.removeEventListener){ bleDevice.removeEventListener('gattserverdisconnected', onDisconnected); } }catch(e){}
      resetBleRefs();
      bleDevice=dev;
      if (bleDevice && bleDevice.addEventListener){ bleDevice.addEventListener('gattserverdisconnected', onDisconnected); }

      bleServer=await bleDevice.gatt.connect();
      bleService=await bleServer.getPrimaryService(SERVICE_UUID);

      try{ writeChar=await bleService.getCharacteristic(0xFFF3);}catch(e){}
      try{ notifyChar=await bleService.getCharacteristic(0xFFF4);}catch(e){}
      if(!writeChar || notifyChar==null){
        var cs=await bleService.getCharacteristics();
        for(var i=0;i<cs.length;i++){
          var ch=cs[i], p=ch.properties||{};
          if(!writeChar && (p.write||p.writeWithoutResponse)) writeChar=ch;
          if(!notifyChar && p.notify) notifyChar=ch;
        }
      }
      if(!writeChar) throw new Error('write íŠ¹ì„±ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
      if(notifyChar){
        await notifyChar.startNotifications();
        if (notifyChar.addEventListener){
          notifyChar.addEventListener('characteristicvaluechanged',function(ev){
            try{ var v=new TextDecoder().decode(ev.target.value||new Uint8Array()); log('â¬…ï¸ '+v.trim()); }catch(e){}
          });
        }
      }
      setConnected(true);
      log('âœ… ì—°ê²°: '+(dev.name||'(ì´ë¦„ ì—†ìŒ)'));
    }catch(e){
      console.error(e); log('âŒ ì—°ê²° ì‹¤íŒ¨: '+e);
      setConnected(false); resetBleRefs();
    }
  })();
}
function onDisconnected(){ log('ğŸ”Œ í•´ì œë¨'); setConnected(false); resetBleRefs(); }
function disconnectBLE(){ try{ if (bleDevice && bleDevice.gatt) bleDevice.gatt.disconnect(); }catch(e){} setConnected(false); resetBleRefs(); }
btnConnect.onclick = ()=> isConnected ? disconnectBLE() : connectBLE();

/* ================= ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° ================= */
function serializeProject(){
  var xmlDom = Blockly.Xml.workspaceToDom(ws);
  var xmlText = Blockly.Xml.domToText(xmlDom);
  return JSON.stringify({type:'xrobo_project_v1', xml: xmlText}, null, 2);
}
function saveProject(){
  var data = serializeProject();
  var suggestedName = 'xrobo_project.json';
  if(window.showSaveFilePicker){
    (async function(){
      try{
        var handle = await showSaveFilePicker({
          suggestedName:suggestedName,
          types:[{description:'XROBO Project', accept:{'application/json':['.json']}}]
        });
        var stream = await handle.createWritable();
        await stream.write(new Blob([data], {type:'application/json'}));
        await stream.close();
        log('ğŸ’¾ ì €ì¥ ì™„ë£Œ');
      }catch(e){ if(!(e && e.name==='AbortError')) log('âš ï¸ ì €ì¥ ì‹¤íŒ¨: '+e); }
    })();
  }else{
    var a=document.createElement('a');
    a.href=URL.createObjectURL(new Blob([data], {type:'application/json'}));
    a.download=suggestedName; a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); }, 1000);
    log('ğŸ’¾ ì €ì¥(ë‹¤ìš´ë¡œë“œ) ì™„ë£Œ');
  }
}
function loadProject(){
  (async function(){
    try{
      var text='';
      if(window.showOpenFilePicker){
        var arr = await showOpenFilePicker({
          types:[{description:'XROBO Project', accept:{'application/json':['.json']}}]
        });
        var handle = arr[0];
        var file = await handle.getFile();
        text = await file.text();
      }else{
        var input=document.createElement('input');
        input.type='file'; input.accept='.json,application/json';
        var pick = new Promise((res,rej)=>{ input.onchange=()=>{ res(input.files[0]||null); }; input.onerror=rej; });
        input.click();
        var file = await pick;
        if(!file) return;
        text = await file.text();
      }
      var obj = JSON.parse(text);
      if(!obj || obj.type!=='xrobo_project_v1') throw new Error('ì•Œ ìˆ˜ ì—†ëŠ” í”„ë¡œì íŠ¸ í˜•ì‹');
      ws.clear();
      var parser = new DOMParser();
      var xml = parser.parseFromString(obj.xml, 'text/xml');
      Blockly.Xml.domToWorkspace(xml.documentElement, ws);
      log('ğŸ“‚ ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ');
    }catch(e){
      if(!(e && e.name==='AbortError')) alert('ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: '+e);
    }
  })();
}
$('saveBtn').addEventListener('click', saveProject);
$('openBtn').addEventListener('click', loadProject);

/* ================= ì˜¤ë¥¸ìª½ íŒ¨ë„: ë¦¬ì‚¬ì´ì € ================= */
(function(){
  var divider = document.getElementById('rightDivider');
  var root = document.documentElement;
  var dragging=false, startY=0, startH=0, rightH=0;
  function pxToNum(px){ return Number(String(px).replace('px',''))||0; }
  function onDown(e){
    e.preventDefault();
    dragging=true;
    startY=('touches' in e ? e.touches[0].clientY : e.clientY);
    startH=pxToNum(getComputedStyle(root).getPropertyValue('--logH'));
    rightH=document.getElementById('right').clientHeight;
    window.addEventListener('mousemove', onMove);
    window.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('mouseup', onUp, {once:true});
    window.addEventListener('touchend', onUp, {once:true});
  }
  function onMove(e){
    if(!dragging) return;
    var y=('touches' in e ? e.touches[0].clientY : e.clientY);
    if('touches' in e) e.preventDefault();
    var delta = startY - y;
    var nh = startH + delta;
    var minH=90, maxH=Math.max(130, Math.floor(rightH*0.8));
    nh=Math.min(maxH, Math.max(minH, nh));
    root.style.setProperty('--logH', nh+'px');
  }
  function onUp(){
    dragging=false;
    window.removeEventListener('mousemove', onMove);
    window.removeEventListener('touchmove', onMove);
  }
  divider.addEventListener('mousedown', onDown);
  divider.addEventListener('touchstart', onDown, {passive:false});
})();

/* ================= íŒ¨ë„ í† ê¸€ & ì „ì²´í™”ë©´ ================= */
var panelHandle=document.getElementById('panelHandle');
function syncHandle(){
  var collapsed = document.body.classList.contains('panel-collapsed');
  panelHandle.classList.toggle('open',   !collapsed);
  panelHandle.classList.toggle('closed',  collapsed);
  panelHandle.title = collapsed ? 'ì‹¤í–‰ì°½ ì—´ê¸°' : 'ì‹¤í–‰ì°½ ë‹«ê¸°';
}
function togglePanel(){ document.body.classList.toggle('panel-collapsed'); syncHandle(); setTimeout(()=>{ Blockly.svgResize(ws); },60); }
panelHandle.addEventListener('click', togglePanel);
syncHandle();

var fsBtn=document.getElementById('fsBtn');
async function enterFS(){ var el=document.documentElement; if(el.requestFullscreen) await el.requestFullscreen(); }
async function exitFS(){ if(document.fullscreenElement && document.exitFullscreen) await document.exitFullscreen(); }
function syncFSLabel(){
  var a = !!document.fullscreenElement;
  document.body.classList.toggle('fs-active', a);
  fsBtn.textContent = a ? 'í™”ë©´ì¶•ì†Œ' : 'ì „ì²´í™”ë©´';
  fsBtn.title = a ? 'í™”ë©´ ì¶•ì†Œë¡œ ì „í™˜' : 'ì „ì²´í™”ë©´ìœ¼ë¡œ ì „í™˜';
  applyHeaderHeight();
}
fsBtn.onclick=async function(){ if(document.fullscreenElement) await exitFS(); else await enterFS(); };
document.addEventListener('fullscreenchange', syncFSLabel);
syncFSLabel();

/* ================= ì‹¤í–‰(ì˜¤ë²„ë ˆì´) ë° ì´ë²¤íŠ¸ ì‹¤í–‰ê¸° ================= */
var overlay=document.getElementById('playOverlay');
var overlayClose=document.getElementById('overlayClose');

var eventPrograms = {};
var queue = [];
var queueBusy = false;
var cancelToken = 0;

function sendRaw(s){
  if(!writeChar){ log('â¡ï¸(ë¯¸ì—°ê²°) '+s); return Promise.resolve(); } // â˜… ë³€ê²½: BLE ì—†ì–´ë„ í†µê³¼
  return writeChar.writeValue(enc(s+'\n'))
    .then(()=>{ log('â¡ï¸ '+s); })
    .catch(e=>{ log('âš ï¸ ì „ì†¡ ì‹¤íŒ¨: '+e); });
}

async function processQueue(localToken){
  if(queueBusy) return;
  queueBusy = true;
  try{
    while(queue.length && localToken === cancelToken){
      var item = queue.shift();
      await runList(item.list, localToken);
    }
  }finally{ queueBusy = false; }
}
async function runList(list, localToken){
  for(var i=0;i<list.length;i++){
    var ins=list[i];
    if(localToken !== cancelToken) return;
    if(ins.type==='CMD'){ await sendRaw(ins.s); }
    else if(ins.type==='W'){ var ms = (ins.args && ins.args[0]) ? ins.args[0] : 0; await new Promise(r=>setTimeout(r, ms)); }
    else if(ins.type==='FOR'){
      for(var k=0;k<ins.count;k++){ if(localToken !== cancelToken) return; await runList(ins.body, localToken); }
    }
  }
}
function triggerEvent(name){
  if(!isRunning) return;
  var seq = eventPrograms[name];
  if(seq && seq.length){
    queue.push({list: seq});
    var myToken = cancelToken;
    processQueue(myToken);
  }
}

btnRun.onclick = function(){
  if(!isRunning){
    eventPrograms = buildEventPrograms();     // â˜… ë³€ê²½: ì¹´ë©”ë¼ ìƒ‰ ì´ë²¤íŠ¸ìš© ë¹Œë“œ
    cancelToken++; queue = [];
    setRunning(true);
  }else{
    cancelToken++; queue=[];
    setRunning(false);
    try{ if(writeChar) writeChar.writeValue(enc('S\n')); }catch(e){}
  }
};
overlayClose.onclick = function(){ if(isRunning) btnRun.click(); };
overlay.addEventListener('keydown', function(e){ if(e.key==='Escape' && isRunning) btnRun.click(); });

/* ================= ì¹´ë©”ë¼: í”„ë¦¬ë·° + 'ë¹¨ê°„ìƒ‰' ê°ì§€ ì´ë²¤íŠ¸ ================= */
/* â˜… ë³€ê²½: ìš°ì¸¡ ìƒë‹¨ ì¹´ë©”ë¼ í”„ë¦¬ë·° ì¼œê¸°/ë„ê¸° + ë¹¨ê°„ìƒ‰ ê°ì§€ ì‹œ ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±° */
const camVideo = $('camVideo');
const camToggle = $('camToggle');
const camBadge  = $('camBadge');

let camStream = null;
let camOn = false;
let camRAF = null;

const LOW_W = 64, LOW_H = 48;    // ì²˜ë¦¬ í•´ìƒë„(ë‚®ì„ìˆ˜ë¡ ê°€ë²¼ì›€)
const S_MIN = 0.35;              // ì±„ë„ ì»·(ì¡°ëª… ì˜í–¥ ì™„í™”)
const V_MIN = 0.20;              // ëª…ë„ ì»·
const RED_ON_COUNT  = 110;       // 'ë¹¨ê°•' í”½ì…€ìˆ˜ ì„ê³„(ON)
const RED_OFF_COUNT = 70;        // OFF ì„ê³„(íˆìŠ¤í…Œë¦¬ì‹œìŠ¤)
const HOLD_ON_MS  = 220;         // ON ë””ë°”ìš´ìŠ¤
const HOLD_OFF_MS = 300;         // OFF ë””ë°”ìš´ìŠ¤

const procCvs = document.createElement('canvas');
const procCtx = procCvs.getContext('2d', { willReadFrequently:true });
procCvs.width = LOW_W; procCvs.height = LOW_H;

let redActive = false;
let redCand = false;
let redCandSince = 0;

function rgb2hsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  const v=max, d=max-min;
  const s = max===0 ? 0 : d/max;
  let h=0;
  if(d!==0){
    switch(max){
      case r: h=(g-b)/d + (g<b?6:0); break;
      case g: h=(b-r)/d + 2; break;
      case b: h=(r-g)/d + 4; break;
    }
    h*=60;
  }
  return {h,s,v};
}
function isRedHue(h){ return (h < 15 || h >= 345); }

function updateCamUi(){
  camBadge.textContent = 'Cam: ' + (camOn ? 'on' : 'off');
  camToggle.textContent = camOn ? 'ìº  ë„ê¸°' : 'ìº  ì¼œê¸°';
}
async function startCam(){
  if(camOn) return;
  try{
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode:{ideal:'user'}, width:{ideal:320}, height:{ideal:240}, frameRate:{ideal:30,max:30} },
      audio: false
    });
    camStream = stream;
    camVideo.srcObject = stream;
    await camVideo.play();
    camOn = true; updateCamUi();
    startDetectLoop();
    log('ğŸ¥ ì¹´ë©”ë¼ ì¼œì§');
  }catch(e){
    log('âŒ ì¹´ë©”ë¼ ì‹¤íŒ¨: '+e);
  }
}
function stopCam(){
  if(!camOn) return;
  try{ camVideo.pause(); }catch(_){}
  if(camVideo.srcObject){
    try{ camVideo.srcObject.getTracks().forEach(t=>t.stop()); }catch(_){}
    camVideo.srcObject = null;
  }
  camStream = null; camOn=false; updateCamUi();
  if(camRAF){ cancelAnimationFrame(camRAF); camRAF=null; }
  // ìƒíƒœ ë¦¬ì…‹
  redActive=false; redCand=false; redCandSince=0;
  log('ğŸ›‘ ì¹´ë©”ë¼ êº¼ì§');
}
camToggle.onclick = ()=> camOn ? stopCam() : startCam();

function startDetectLoop(){
  const step = ()=>{
    if(!camOn || camVideo.readyState < 2){ camRAF = requestAnimationFrame(step); return; }
    // ë‹¤ìš´ìƒ˜í”Œ ìº¡ì²˜
    procCtx.drawImage(camVideo, 0, 0, LOW_W, LOW_H);
    const data = procCtx.getImageData(0,0,LOW_W,LOW_H).data;

    // ë¹¨ê°• í”½ì…€ ì¹´ìš´íŠ¸
    let redCount = 0;
    for(let p=0; p<data.length; ){
      const r = data[p++], g = data[p++], b = data[p++]; p++; // alpha skip
      const {h,s,v} = rgb2hsv(r,g,b);
      if (s > S_MIN && v > V_MIN && isRedHue(h)) redCount++;
    }

    const now = performance.now();
    const wantOn = redCount >= RED_ON_COUNT;
    const wantOff= redCount <= RED_OFF_COUNT;

    if(!redActive){
      if(!redCand && wantOn){ redCand=true; redCandSince=now; }
      if(redCand && wantOn && (now - redCandSince) >= HOLD_ON_MS){
        redActive = true; redCand=false;
        log('ğŸ”´ ë¹¨ê°„ìƒ‰ ê°ì§€ë¨ (ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±°)');
        triggerEvent('RED');  // â˜… ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±°
      }
      if(!wantOn) { redCand=false; }
    }else{
      // active â†’ off ë””ë°”ìš´ìŠ¤
      if(!redCand && wantOff){ redCand=true; redCandSince=now; }
      if(redCand && wantOff && (now - redCandSince) >= HOLD_OFF_MS){
        redActive = false; redCand=false;
        log('âšª ë¹¨ê°„ìƒ‰ í•´ì œ');
      }
      if(!wantOff){ redCand=false; }
    }

    camRAF = requestAnimationFrame(step);
  };
  camRAF = requestAnimationFrame(step);
}

/* ================= ë ================= */
</script>
</body>
</html>
