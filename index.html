<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Robot Eyes (Cam Motion + 6-Color Detect)</title>
<style>
  :root{
    --eye-gap: 8vmin;          /* 세로 기준 간격 */
    --eye-size: 42vmin;        /* 세로 기준 크기 */
    --pupil-size: 16vmin;
    --blink-speed: 180ms;
    --bg: #000;
  }
  html, body{
    height:100%; margin:0; background:var(--bg);
    touch-action:none; overscroll-behavior:contain; -webkit-tap-highlight-color:transparent;
  }
  /* 가로: 눈 1.5배, 간격 2배 */
  @media (orientation: landscape){
    :root{
      --eye-size: calc(42vmin * 1.5);
      --pupil-size: calc(16vmin * 1.5);
      --eye-gap: calc(8vmin * 2);
    }
  }

  /* 우상단 전체화면 버튼 */
  #fsBtn{
    position: fixed;
    top: calc(10px + env(safe-area-inset-top));
    right: calc(10px + env(safe-area-inset-right));
    z-index: 10;
    font: 600 14px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    padding: .6rem .9rem; border-radius: 999px;
    border: 1px solid rgba(128,200,255,.6);
    background: rgba(64,160,255,.22); color:#fff;
    backdrop-filter: blur(6px); cursor: pointer;
  }
  #fsBtn.hidden{ display:none; }
  #fsBtn:active{ transform: translateY(1px); }

  /* 좌상단 상태 배지(카메라) */
  #camStatus{
    position: fixed; top:12px; left:12px; z-index:10;
    font:600 12px system-ui; color:#fff; padding:.35rem .6rem;
    border:1px solid rgba(255,255,255,.3); border-radius:999px;
    background:rgba(0,0,0,.35); backdrop-filter:blur(6px)
  }

  /* 하단 색상 인식 배지 (색이 바뀔 때만 갱신) */
  #colorBadge{
    position: fixed; left:50%; transform:translateX(-50%);
    bottom: calc(12px + env(safe-area-inset-bottom));
    z-index: 10;
    display: none;
    font: 700 14px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    color: #fff; padding:.5rem .8rem; border-radius: 999px;
    border:1px solid rgba(255,255,255,.3);
    background: rgba(0,0,0,.35); backdrop-filter: blur(6px);
  }
  #colorBadge .dot{
    display:inline-block; width:.9em; height:.9em; border-radius:50%;
    margin-right:.5em; vertical-align:-0.12em; box-shadow:0 0 0 2px rgba(255,255,255,.2) inset;
  }

  /* 처리용 전면 카메라 프리뷰(아주 작게, 거울효과) */
  video#cam{
    position: fixed; left:0; bottom:0; width:12px; height:12px;
    opacity: .05; pointer-events:none; z-index:0; transform: scaleX(-1);
  }

  .face{ height:100%; display:grid; place-items:center; }
  .eyes{ display:grid; grid-auto-flow:column; align-items:center; gap:var(--eye-gap); }
  .eye{
    position:relative; width:var(--eye-size); height:var(--eye-size);
    border-radius:50%; overflow:hidden;
    background: radial-gradient(ellipse at 40% 40%, #fff 0 70%, #e9e9e9 100%);
    box-shadow: 0 1.2vmin 3vmin rgba(0,0,0,.45), inset 0 -0.8vmin 1.6vmin rgba(0,0,0,.12);
  }
  .pupil{
    position:absolute; width:var(--pupil-size); height:var(--pupil-size);
    border-radius:50%; background: radial-gradient(circle at 40% 35%, #222 0 45%, #000 70%, #000 100%);
    left:50%; top:50%; transform:translate(-50%,-50%); will-change: transform;
  }
  .shine{
    position:absolute; width: calc(var(--pupil-size)*.35); height: calc(var(--pupil-size)*.35);
    border-radius:50%; background: rgba(255,255,255,.85); left:25%; top:22%; filter: blur(0.2vmin);
  }
  .shine::after{
    content:""; position:absolute; width:55%; height:55%; left:150%; top:130%;
    border-radius:50%; background: rgba(255,255,255,.4); filter: blur(0.25vmin);
  }
  .eyelid{ position:absolute; inset:0; background:var(--bg); transform-origin:top center; transform:scaleY(0); pointer-events:none; }
  .blink .eyelid{ animation: blink var(--blink-speed) ease-in-out forwards; }
  @keyframes blink{ 0%{transform:scaleY(0)} 45%{transform:scaleY(1)} 100%{transform:scaleY(0)} }
</style>
</head>
<body>
  <button id="fsBtn">전체화면</button>
  <div id="camStatus">Cam: off</div>
  <div id="colorBadge"><span class="dot"></span><span class="label">—</span></div>

  <!-- 전면 카메라(처리용) -->
  <video id="cam" playsinline muted autoplay></video>

  <div class="face" id="face">
    <div class="eyes">
      <div class="eye"><div class="pupil"><div class="shine"></div></div><div class="eyelid"></div></div>
      <div class="eye"><div class="pupil"><div class="shine"></div></div><div class="eyelid"></div></div>
    </div>
  </div>

<script>
(() => {
  const root = document.documentElement;
  const fsBtn = document.getElementById('fsBtn');
  const camVid = document.getElementById('cam');
  const camBadge = document.getElementById('camStatus');
  const colorBadge = document.getElementById('colorBadge');
  const colorDot = colorBadge.querySelector('.dot');
  const colorLabel = colorBadge.querySelector('.label');

  const eyes = [...document.querySelectorAll('.eye')];
  const pupils = [...document.querySelectorAll('.pupil')];

  const setCamBadge = t => camBadge && (camBadge.textContent = 'Cam: ' + t);

  /* ===== 깜빡임(랜덤) ===== */
  (function scheduleBlink(){
    const t = 2200 + Math.random()*3300;
    setTimeout(() => {
      eyes.forEach(e => {
        e.classList.add('blink');
        setTimeout(() => e.classList.remove('blink'),
          parseFloat(getComputedStyle(root).getPropertyValue('--blink-speed')) + 40);
      });
      scheduleBlink();
    }, t);
  })();

  /* ===== 동공 이동: 스무딩(lerp) + 입력 소스 통합 ===== */
  let target = {x:0, y:0};
  let current = {x:0, y:0};
  const clamp1 = v => Math.max(-1, Math.min(1, v));
  const lerp = (a,b,t)=> a + (b-a)*t;

  function renderPupils(nx, ny){
    eyes.forEach((eye, i) => {
      const rect = eye.getBoundingClientRect();
      const rEye = Math.min(rect.width, rect.height)/2;
      const limit = rEye * 0.32;
      const dx = nx * limit, dy = ny * limit;
      const dist = Math.hypot(dx,dy);
      const r = dist>limit ? (limit/dist) : 1;
      pupils[i].style.transform =
        `translate(calc(-50% + ${dx*r}px), calc(-50% + ${dy*r}px))`;
    });
  }
  function tick(){
    current.x = lerp(current.x, target.x, 0.20);
    current.y = lerp(current.y, target.y, 0.20);
    renderPupils(current.x, current.y);
    requestAnimationFrame(tick);
  }
  tick();

  /* ===== 포인터(터치/드래그) 우선 ===== */
  let pointerActive = false;
  let pointerIdleTimer = null;
  function setTarget(nx,ny){ target.x = clamp1(nx); target.y = clamp1(ny); }
  function handlePointer(e){
    const pt = ('touches' in e) ? e.touches[0] : e;
    const cx = innerWidth/2, cy = innerHeight/2;
    const dx = pt.clientX - cx, dy = pt.clientY - cy;
    const d = Math.hypot(innerWidth, innerHeight) || 1;
    setTarget(dx/(d*0.25), dy/(d*0.25));
    pointerActive = true;
    clearTimeout(pointerIdleTimer);
    pointerIdleTimer = setTimeout(()=> { pointerActive = false; }, 900);
  }
  addEventListener('pointermove', handlePointer, {passive:true});
  addEventListener('pointerdown', handlePointer, {passive:true});

  /* ===== 전면 카메라: 움직임 방향 + 색상 인식 ===== */
  let camStream = null;
  const LOW_W = 64, LOW_H = 48;              // 다운샘플 크기
  const DIFF_T = 22;                         // 프레임차 임계 (노이즈 컷)
  const MASS_T = 14000;                      // 모션 총량 임계 (색 판정 최소 조건)
  const S_T = 0.25, V_T = 0.18;              // 저채도/저명도 컷
  const HOLD_MS = 280;                       // 색 변경 디바운스 시간
  const CATS = ['빨','주','노','초','파','보'];
  const CAT2FULL = { '빨':'빨강','주':'주황','노':'노랑','초':'초록','파':'파랑','보':'보라' };
  const CAT2H =   { '빨':0, '주':28, '노':55, '초':120, '파':210, '보':285 }; // 표시용 대표 Hue

  let procCvs = document.createElement('canvas');
  let procCtx = procCvs.getContext('2d', { willReadFrequently:true });
  procCvs.width = LOW_W; procCvs.height = LOW_H;

  let prevGray = null;
  let motionRAF = null;
  let camEnabled = false;

  // HSV 변환 (0-255 RGB -> H:0..360, S:0..1, V:0..1)
  function rgb2hsv(r,g,b){
    r/=255; g/=255; b/=255;
    const max = Math.max(r,g,b), min = Math.min(r,g,b);
    const v = max;
    const d = max - min;
    const s = max === 0 ? 0 : d / max;
    let h = 0;
    if (d !== 0){
      switch(max){
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h *= 60;
    }
    return {h, s, v};
  }

  // Hue → 6색 분류
  function hueToCat(h){
    if (h < 15 || h >= 345) return '빨';  // Red
    if (h < 40) return '주';              // Orange
    if (h < 70) return '노';              // Yellow
    if (h < 170) return '초';             // Green
    if (h < 250) return '파';             // Blue
    return '보';                          // Violet/Magenta
  }

  // 배지 표시/갱신 (색이 바뀔 때만)
  let committedCat = null;
  let candidateCat = null;
  let candidateSince = 0;
  function updateColorBadge(newCat, hueForDot){
    if (newCat === committedCat) return;
    const now = performance.now();
    if (candidateCat !== newCat){
      candidateCat = newCat; candidateSince = now; return;
    }
    if (now - candidateSince < HOLD_MS) return; // 안정화 대기

    // 커밋
    committedCat = newCat;
    colorDot.style.background = `hsl(${Math.round(hueForDot)}, 85%, 55%)`;
    colorLabel.textContent = `${newCat} (${CAT2FULL[newCat]})`;
    colorBadge.style.display = 'inline-flex';
  }

  async function startCam(){
    if (camEnabled) return;
    if (!navigator.mediaDevices?.getUserMedia){
      setCamBadge('unavailable'); return;
    }
    try{
      camStream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal:'user' }, width:{ideal:320}, height:{ideal:240}, frameRate:{ideal:30,max:30} },
        audio: false
      });
      camVid.srcObject = camStream;
      await camVid.play();
      camEnabled = true;
      setCamBadge('on');
      startMotionLoop();
    }catch(err){
      console.log('camera error', err);
      setCamBadge('denied');
      stopCam();
    }
  }
  function stopCam(){
    camEnabled = false;
    setCamBadge('off');
    if (motionRAF){ cancelAnimationFrame(motionRAF); motionRAF = null; }
    prevGray = null;
    try{
      camVid.pause();
      if (camVid.srcObject){
        camVid.srcObject.getTracks().forEach(t=>t.stop());
        camVid.srcObject = null;
      }
    }catch(_){}
  }

  function startMotionLoop(){
    const step = ()=>{
      if (!camEnabled || camVid.readyState < 2){ motionRAF = requestAnimationFrame(step); return; }

      procCtx.drawImage(camVid, 0, 0, LOW_W, LOW_H);
      const img = procCtx.getImageData(0,0,LOW_W,LOW_H);
      const data = img.data;

      // --- 그레이월드(간단 화밸) 보정용 평균 RGB (프레임 전체 기준) ---
      let sumR=0,sumG=0,sumB=0;
      for(let p=0; p<data.length; p+=4){ sumR+=data[p]; sumG+=data[p+1]; sumB+=data[p+2]; }
      const nPix = LOW_W*LOW_H;
      const mR=sumR/nPix, mG=sumG/nPix, mB=sumB/nPix;
      const avg=(mR+mG+mB)/3 || 1;
      const gR = avg/(mR||1), gG = avg/(mG||1), gB = avg/(mB||1); // 채널 게인

      // --- 모션 + 색상 누적 ---
      if (!prevGray) prevGray = new Uint8ClampedArray(nPix);
      let mass = 0;
      // 움직임 무게중심(시선용)
      let sx=0, sy=0;
      // 6색 누적 가중치
      const acc = { '빨':0,'주':0,'노':0,'초':0,'파':0,'보':0 };

      // 한 번에 순회
      for (let y=0, i=0, p=0; y<LOW_H; y++){
        for (let x=0; x<LOW_W; x++, i++){
          const r0 = data[p++], g0 = data[p++], b0 = data[p++]; p++; // a skip
          // 모션은 원본 그레이로
          const gray = (r0*0.299 + g0*0.587 + b0*0.114)|0;
          const d = Math.abs(gray - prevGray[i]);
          prevGray[i] = gray;

          if (d > DIFF_T){
            // 시선용 무게중심
            sx += (x - LOW_W/2) * d;
            sy += (y - LOW_H/2) * d;
            mass += d;

            // 색 추정: 화밸 보정 후 HSV, 저채도/저명도는 제외
            const r = Math.min(255, r0 * gR);
            const g = Math.min(255, g0 * gG);
            const b = Math.min(255, b0 * gB);
            const {h,s,v} = rgb2hsv(r,g,b);
            if (s > S_T && v > V_T){
              // 가중치: d * s^1.3 (채도가 높은 픽셀 우대)
              const w = d * Math.pow(s, 1.3);
              acc[hueToCat(h)] += w;
            }
          }
        }
      }

      // ===== 눈동자: 모션 방향으로 (터치 중이면 무시)
      if (!pointerActive){
        if (mass > MASS_T){
          let nx = -(sx/mass)/(LOW_W/2);  // 전면카메라 x축 반전
          let ny =  (sy/mass)/(LOW_H/2);
          const dead=0.06;
          nx = Math.abs(nx)<dead ? 0 : nx;
          ny = Math.abs(ny)<dead ? 0 : ny;
          target.x = clamp1(nx*1.2);
          target.y = clamp1(ny*1.2);
        }else{
          // 모션 없으면 서서히 중앙 복귀
          target.x *= 0.985; target.y *= 0.985;
        }
      }

      // ===== 색상 인식: 변화 있을 때만 배지 갱신
      const totalW = CATS.reduce((s,k)=>s+acc[k],0);
      if (mass > MASS_T && totalW > 0){
        // 가장 강한 색과 신뢰도
        let topCat = '빨', topW = -1;
        for(const k of CATS){ if (acc[k] > topW){ topW = acc[k]; topCat = k; } }
        const conf = topW / (totalW || 1);
        // 너무 애매하면 무시(조명 영향 감소)
        if (conf >= 0.55){
          updateColorBadge(topCat, CAT2H[topCat]);
        }
      }

      motionRAF = requestAnimationFrame(step);
    };
    motionRAF = requestAnimationFrame(step);
  }

  /* ===== 전체화면 토글 & 더블탭 종료 ===== */
  const inFS = ()=> !!document.fullscreenElement;
  function onFSChange(){
    const fs = inFS();
    fsBtn.textContent = fs ? '전체화면 해제' : '전체화면';
    fsBtn.classList.toggle('hidden', fs);

    if (fs) startCam();
    else { stopCam(); /* 배터지 절약 */ }
  }
  fsBtn.addEventListener('click', async ()=>{
    try{
      if(!inFS()) await document.documentElement.requestFullscreen();
      else await document.exitFullscreen();
    }catch(_){}
  });
  document.addEventListener('fullscreenchange', onFSChange);

  // 더블클릭/더블탭으로 전체화면 종료
  addEventListener('dblclick', async ()=>{ if(inFS()) try{ await document.exitFullscreen(); }catch(_){}});

  let lastTap=0; const GAP=300;
  addEventListener('pointerup', async (e)=>{
    // 재미용 깜빡
    eyes.forEach(el=>{
      el.classList.add('blink');
      setTimeout(()=>el.classList.remove('blink'),
        parseFloat(getComputedStyle(root).getPropertyValue('--blink-speed')) + 40);
    });
    if(!inFS()) return;
    const now = e.timeStamp||Date.now();
    if(now-lastTap<=GAP){ try{ await document.exitFullscreen(); }catch(_){} lastTap=0; }
    else lastTap=now;
  });

  // 백그라운드/복귀 처리
  document.addEventListener('visibilitychange', ()=>{
    if (document.hidden) stopCam();
    else if (inFS()) startCam();
  });
})();
</script>
</body>
</html>
