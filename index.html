<script>
/* ================= 카메라: 프리뷰 + 색 감지 + 움직임 초점 (이전 알고리즘 복원) ================= */
const camVideo = $('camVideo');
const camToggle = $('camToggle');
const camBadge  = $('camBadge');
const focusBox  = $('focusBox');
const colorReadout = $('colorReadout');
const colorDot = colorReadout.querySelector('.dot');
const colorLabel = colorReadout.querySelector('.label');

let camStream = null, camOn = false, camRAF = null;

/* === 파라미터 (이전값으로 복원) === */
const LOW_W = 64, LOW_H = 48;       // 처리 해상도
const DIFF_T = 22;                   // 프레임 차 임계(모션 픽셀)
const MASS_T = 14000;                // 모션 총량 임계(충분히 움직일 때만 색 판정)
const S_T = 0.25;                    // 채도 컷
const V_T = 0.18;                    // 명도 컷
const HOLD_MS = 280;                 // 색 변경 디바운스
const CONF_MIN = 0.55;               // 최상위 색 비율 최소 신뢰도
const FOCUS_LERP = 0.20;             // 초점 이동 스무딩(그대로)

const NAME_KR = { RED:'빨간색', ORG:'주황색', YEL:'노란색', GRN:'초록색', BLU:'파랑색', VIO:'보라색', NONE:'색없음' };
const HUE_MAP = { RED:0, ORG:28, YEL:55, GRN:120, BLU:210, VIO:285 };

const procCvs = document.createElement('canvas');
const procCtx = procCvs.getContext('2d', { willReadFrequently:true });
procCvs.width = LOW_W; procCvs.height = LOW_H;

/* 유틸: RGB→HSV, Hue→카테고리 (기존과 동일) */
function rgb2hsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  const v=max, d=max-min;
  const s = max===0 ? 0 : d/max;
  let h=0;
  if(d!==0){
    switch(max){
      case r: h=(g-b)/d + (g<b?6:0); break;
      case g: h=(b-r)/d + 2; break;
      case b: h=(r-g)/d + 4; break;
    }
    h*=60;
  }
  return {h,s,v};
}
function hueToCat(h){
  if (h < 15 || h >= 345) return 'RED';
  if (h < 40)  return 'ORG';
  if (h < 70)  return 'YEL';
  if (h < 170) return 'GRN';
  if (h < 250) return 'BLU';
  return 'VIO';
}

/* UI 업데이트 (기존 로직 유지) */
function updateCamUi(){
  camBadge.textContent = 'Cam: ' + (camOn ? 'on' : 'off');
  camToggle.textContent = camOn ? '캠 끄기' : '캠 켜기';
}
function updateColorReadout(code){
  const name = NAME_KR[code] || '색없음';
  colorLabel.textContent = name;
  if (code && code !== 'NONE' && HUE_MAP[code] != null){
    colorDot.style.background = `hsl(${HUE_MAP[code]}, 85%, 55%)`;
  }else{
    colorDot.style.background = '#777';
  }
}

/* 캠 ON/OFF (기존과 동일) */
async function startCam(){
  if(camOn) return;
  try{
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode:{ideal:'user'}, width:{ideal:320}, height:{ideal:240}, frameRate:{ideal:30,max:30} },
      audio: false
    });
    camStream = stream;
    camVideo.srcObject = stream;
    await camVideo.play();
    camOn = true; updateCamUi();
    startDetectLoop();
    log('🎥 카메라 켜짐');
  }catch(e){ log('❌ 카메라 실패: '+e); }
}
function stopCam(){
  if(!camOn) return;
  try{ camVideo.pause(); }catch(_){}
  if(camVideo.srcObject){
    try{ camVideo.srcObject.getTracks().forEach(t=>t.stop()); }catch(_){}
    camVideo.srcObject = null;
  }
  camStream = null; camOn=false; updateCamUi();
  if(camRAF){ cancelAnimationFrame(camRAF); camRAF=null; }
  // 상태 리셋
  activeColor='NONE'; candColor='NONE'; lastEventColor=null;
  updateColorReadout('NONE');
  focusBox.style.opacity='.15';
  focusBox.style.left='50%'; focusBox.style.top='50%';
  log('🛑 카메라 꺼짐');
}
camToggle.onclick = ()=> camOn ? stopCam() : startCam();

/* 색 안정화/이벤트 상태 (변경 없음) */
let activeColor = 'NONE';   // 화면에 표시중인 확정 색
let candColor   = 'NONE';   // 후보 색
let candSince   = 0;
let lastEventColor = null;  // 마지막 이벤트 색

/* === 핵심: 이전 알고리즘으로 복원된 검출 루프 === */
function startDetectLoop(){
  const step = ()=>{
    if(!camOn || camVideo.readyState < 2){ camRAF = requestAnimationFrame(step); return; }

    // 0) 프레임 캡처
    procCtx.drawImage(camVideo, 0, 0, LOW_W, LOW_H);
    const img = procCtx.getImageData(0,0,LOW_W,LOW_H);
    const data = img.data;

    // 1) 그레이월드(화이트밸런스) 보정 게인 계산 (프레임 전체 평균)
    let sumR=0,sumG=0,sumB=0;
    for(let p=0;p<data.length;p+=4){ sumR+=data[p]; sumG+=data[p+1]; sumB+=data[p+2]; }
    const nPix = LOW_W*LOW_H;
    const mR=sumR/nPix, mG=sumG/nPix, mB=sumB/nPix;
    const avg=(mR+mG+mB)/3 || 1;
    const gR = avg/(mR||1), gG = avg/(mG||1), gB = avg/(mB||1);

    // 2) 모션 + 색 누적 (이전 방식)
    if (!step.prevGray) step.prevGray = new Uint8ClampedArray(nPix);
    let mass=0, sxa=0, sya=0;
    const acc = { RED:0, ORG:0, YEL:0, GRN:0, BLU:0, VIO:0 };

    for(let y=0, i=0, p=0; y<LOW_H; y++){
      for(let x=0; x<LOW_W; x++, i++){
        const r0=data[p++], g0=data[p++], b0=data[p++]; p++; // a skip

        // 모션 픽셀 선별
        const gray = (r0*0.299 + g0*0.587 + b0*0.114)|0;
        const d = Math.abs(gray - step.prevGray[i]);
        step.prevGray[i] = gray;
        if (d > DIFF_T){
          // 모션 무게중심(초점 박스용)
          sxa += x*d; sya += y*d; mass += d;

          // 색 추정: 화밸 보정 → HSV → 컷
          const r = Math.min(255, r0*gR);
          const g = Math.min(255, g0*gG);
          const b = Math.min(255, b0*gB);
          const {h,s,v} = rgb2hsv(r,g,b);
          if (s > S_T && v > V_T){
            // 가중치: 모션 강도 d × 채도^1.3  (이전과 동일)
            const w = d * Math.pow(s, 1.3);
            acc[hueToCat(h)] += w;
          }
        }
      }
    }

    // 3) 움직임 초점 박스 (모션량 충분할 때만)
    if (mass > MASS_T){
      const cx = sxa / mass, cy = sya / mass;        // 0..LOW_W-1 / 0..LOW_H-1
      const fx = 1 - (cx / (LOW_W-1));               // 전면카메라 거울 보정
      const fy =      (cy / (LOW_H-1));
      const lerp = (a,b,t)=> a + (b-a)*t;
      const curL = parseFloat((focusBox.style.left||'50%'))/100 || .5;
      const curT = parseFloat((focusBox.style.top ||'50%'))/100 || .5;
      const nx = lerp(curL, fx, FOCUS_LERP);
      const ny = lerp(curT, fy, FOCUS_LERP);
      focusBox.style.left = (nx*100).toFixed(1)+'%';
      focusBox.style.top  = (ny*100).toFixed(1)+'%';
      focusBox.style.opacity = '1';
    }else{
      focusBox.style.opacity = '.15';
    }

    // 4) 색 판정 (모션량이 충분할 때만) → 디바운스 → 변경시에만 이벤트
    const totalW = acc.RED+acc.ORG+acc.YEL+acc.GRN+acc.BLU+acc.VIO;
    let frameColor = 'NONE';
    if (mass > MASS_T && totalW > 0){
      let top='RED', topW=-1;
      for(const k in acc){ if(acc[k] > topW){ topW=acc[k]; top=k; } }
      const conf = topW / totalW;
      if (conf >= CONF_MIN) frameColor = top;    // 아니면 'NONE'
    }

    const now = performance.now();
    if (candColor !== frameColor){ candColor = frameColor; candSince = now; }
    if ((now - candSince) >= HOLD_MS && activeColor !== frameColor){
      activeColor = frameColor;                  // 확정
      updateColorReadout(activeColor);           // 하단 표시

      if (activeColor !== 'NONE' && lastEventColor !== activeColor){
        lastEventColor = activeColor;            // “변경시에만” 이벤트 실행
        log('🎯 색 감지: ' + activeColor + ' (이벤트 실행)');
        triggerEvent(activeColor);
      }
      if (activeColor === 'NONE'){ log('◽ 색없음'); }
    }

    camRAF = requestAnimationFrame(step);
  };
  camRAF = requestAnimationFrame(step);
}
</script>
