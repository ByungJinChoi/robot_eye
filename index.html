<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Robot Eyes (Front Cam Motion Follow)</title>
<style>
  :root{
    --eye-gap: 8vmin;          /* 세로 기준 간격 */
    --eye-size: 42vmin;        /* 세로 기준 크기 */
    --pupil-size: 16vmin;
    --blink-speed: 180ms;
    --bg: #000;
  }
  html, body{
    height:100%; margin:0; background:var(--bg);
    touch-action:none; overscroll-behavior:contain; -webkit-tap-highlight-color:transparent;
  }
  /* 가로: 눈 1.5배, 간격 2배 */
  @media (orientation: landscape){
    :root{
      --eye-size: calc(42vmin * 1.5);
      --pupil-size: calc(16vmin * 1.5);
      --eye-gap: calc(8vmin * 2);
    }
  }

  /* 우상단 전체화면 버튼 */
  #fsBtn{
    position: fixed;
    top: calc(10px + env(safe-area-inset-top));
    right: calc(10px + env(safe-area-inset-right));
    z-index: 10;
    font: 600 14px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    padding: .6rem .9rem; border-radius: 999px;
    border: 1px solid rgba(128,200,255,.6);
    background: rgba(64,160,255,.22); color:#fff;
    backdrop-filter: blur(6px); cursor: pointer;
  }
  #fsBtn.hidden{ display:none; }
  #fsBtn:active{ transform: translateY(1px); }

  /* 좌상단 상태 배지(선택) */
  #camStatus{
    position: fixed; top:12px; left:12px; z-index:10;
    font:600 12px system-ui; color:#fff; padding:.35rem .6rem;
    border:1px solid rgba(255,255,255,.3); border-radius:999px;
    background:rgba(0,0,0,.35); backdrop-filter:blur(6px)
  }

  /* 숨김 카메라 프리뷰(처리용): 일부 기기는 화면 내에 있어야 프레임 갱신이 안정적 */
  video#cam{
    position: fixed; left:0; bottom:0; width:12px; height:12px;
    opacity: .05; pointer-events:none; z-index:0; transform: scaleX(-1); /* 전면카메라 거울 효과 */
  }

  .face{ height:100%; display:grid; place-items:center; }
  .eyes{ display:grid; grid-auto-flow:column; align-items:center; gap:var(--eye-gap); }
  .eye{
    position:relative; width:var(--eye-size); height:var(--eye-size);
    border-radius:50%; overflow:hidden;
    background: radial-gradient(ellipse at 40% 40%, #fff 0 70%, #e9e9e9 100%);
    box-shadow: 0 1.2vmin 3vmin rgba(0,0,0,.45), inset 0 -0.8vmin 1.6vmin rgba(0,0,0,.12);
  }
  .pupil{
    position:absolute; width:var(--pupil-size); height:var(--pupil-size);
    border-radius:50%; background: radial-gradient(circle at 40% 35%, #222 0 45%, #000 70%, #000 100%);
    left:50%; top:50%; transform:translate(-50%,-50%); will-change: transform;
  }
  .shine{
    position:absolute; width: calc(var(--pupil-size)*.35); height: calc(var(--pupil-size)*.35);
    border-radius:50%; background: rgba(255,255,255,.85); left:25%; top:22%; filter: blur(0.2vmin);
  }
  .shine::after{
    content:""; position:absolute; width:55%; height:55%; left:150%; top:130%;
    border-radius:50%; background: rgba(255,255,255,.4); filter: blur(0.25vmin);
  }
  .eyelid{ position:absolute; inset:0; background:var(--bg); transform-origin:top center; transform:scaleY(0); pointer-events:none; }
  .blink .eyelid{ animation: blink var(--blink-speed) ease-in-out forwards; }
  @keyframes blink{ 0%{transform:scaleY(0)} 45%{transform:scaleY(1)} 100%{transform:scaleY(0)} }
</style>
</head>
<body>
  <button id="fsBtn">전체화면</button>
  <div id="camStatus">Cam: off</div>

  <!-- 전면 카메라 프리뷰(처리용, 매우 작고 흐리게 표시) -->
  <video id="cam" playsinline muted autoplay></video>

  <div class="face" id="face">
    <div class="eyes">
      <div class="eye"><div class="pupil"><div class="shine"></div></div><div class="eyelid"></div></div>
      <div class="eye"><div class="pupil"><div class="shine"></div></div><div class="eyelid"></div></div>
    </div>
  </div>

<script>
(() => {
  const root = document.documentElement;
  const fsBtn = document.getElementById('fsBtn');
  const camVid = document.getElementById('cam');
  const camBadge = document.getElementById('camStatus');
  const eyes = [...document.querySelectorAll('.eye')];
  const pupils = [...document.querySelectorAll('.pupil')];

  const setCamBadge = t => camBadge && (camBadge.textContent = 'Cam: ' + t);

  /* ===== 깜빡임(랜덤) ===== */
  (function scheduleBlink(){
    const t = 2200 + Math.random()*3300;
    setTimeout(() => {
      eyes.forEach(e => {
        e.classList.add('blink');
        setTimeout(() => e.classList.remove('blink'),
          parseFloat(getComputedStyle(root).getPropertyValue('--blink-speed')) + 40);
      });
      scheduleBlink();
    }, t);
  })();

  /* ===== 동공 이동: 스무딩(lerp) + 입력 소스 통합 ===== */
  let target = {x:0, y:0};
  let current = {x:0, y:0};
  const clamp1 = v => Math.max(-1, Math.min(1, v));
  const lerp = (a,b,t)=> a + (b-a)*t;

  function renderPupils(nx, ny){
    eyes.forEach((eye, i) => {
      const rect = eye.getBoundingClientRect();
      const rEye = Math.min(rect.width, rect.height)/2;
      const limit = rEye * 0.32;
      const dx = nx * limit, dy = ny * limit;
      const dist = Math.hypot(dx,dy);
      const r = dist>limit ? (limit/dist) : 1;
      pupils[i].style.transform =
        `translate(calc(-50% + ${dx*r}px), calc(-50% + ${dy*r}px))`;
    });
  }
  function tick(){
    // 스무딩 강도(0.18~0.28 사이 취향대로)
    current.x = lerp(current.x, target.x, 0.20);
    current.y = lerp(current.y, target.y, 0.20);
    renderPupils(current.x, current.y);
    requestAnimationFrame(tick);
  }
  tick();

  /* ===== 포인터(터치/드래그) 우선 ===== */
  let pointerActive = false;
  let pointerIdleTimer = null;
  function setTarget(nx,ny){ target.x = clamp1(nx); target.y = clamp1(ny); }
  function handlePointer(e){
    const pt = ('touches' in e) ? e.touches[0] : e;
    const cx = innerWidth/2, cy = innerHeight/2;
    const dx = pt.clientX - cx, dy = pt.clientY - cy;
    const d = Math.hypot(innerWidth, innerHeight) || 1;
    setTarget(dx/(d*0.25), dy/(d*0.25));
    pointerActive = true;
    clearTimeout(pointerIdleTimer);
    pointerIdleTimer = setTimeout(()=> { pointerActive = false; }, 900);
  }
  addEventListener('pointermove', handlePointer, {passive:true});
  addEventListener('pointerdown', handlePointer, {passive:true});

  /* ===== 전면 카메라: 모션 방향 추적 ===== */
  let camStream = null;
  let procCvs = document.createElement('canvas');
  let procCtx = procCvs.getContext('2d', { willReadFrequently:true });
  const LOW_W = 64, LOW_H = 48;      // 다운샘플 크기(부하/감도 트레이드오프)
  const DIFF_T = 22;                 // 픽셀 차이 임계값(노이즈 컷)
  const MASS_T = 16000;              // 모션 총량 임계(환경 노이즈 무시)

  let prevGray = null;
  let motionRAF = null;
  let camEnabled = false;

  async function startCamFollow(){
    if (camEnabled) return;
    if (!navigator.mediaDevices?.getUserMedia){
      setCamBadge('unavailable'); return;
    }
    try{
      camStream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: 'user' },   // 전면 카메라
          width: { ideal: 320 }, height: { ideal: 240 },
          frameRate: { ideal: 30, max: 30 }
        },
        audio: false
      });
      camVid.srcObject = camStream;
      await camVid.play();
      camEnabled = true;
      setCamBadge('on');
      startMotionLoop();
    }catch(err){
      console.log('camera error', err);
      setCamBadge('denied');
      stopCamFollow();
    }
  }
  function stopCamFollow(){
    camEnabled = false;
    setCamBadge('off');
    if (motionRAF){ cancelAnimationFrame(motionRAF); motionRAF = null; }
    prevGray = null;
    try{
      camVid.pause();
      if (camVid.srcObject){
        camVid.srcObject.getTracks().forEach(t=>t.stop());
        camVid.srcObject = null;
      }
    }catch(_){}
  }

  function startMotionLoop(){
    procCvs.width = LOW_W;
    procCvs.height = LOW_H;
    const step = ()=>{
      if (!camEnabled || camVid.readyState < 2){ motionRAF = requestAnimationFrame(step); return; }

      // 다운샘플 캡처
      procCtx.drawImage(camVid, 0, 0, LOW_W, LOW_H);
      const img = procCtx.getImageData(0,0,LOW_W,LOW_H).data;

      // 그레이스케일 + 차이
      let sx = 0, sy = 0, mass = 0;
      if (!prevGray) prevGray = new Uint8ClampedArray(LOW_W*LOW_H);

      for (let y=0, i=0, p=0; y<LOW_H; y++){
        for (let x=0; x<LOW_W; x++, i++){
          const r = img[p++], g = img[p++], b = img[p++]; p++; // skip a
          const gray = (r*0.299 + g*0.587 + b*0.114)|0;
          const d = Math.abs(gray - prevGray[i]);
          prevGray[i] = gray;
          if (d > DIFF_T){
            const w = d;           // 가중치 = 차이 크기
            sx += (x - LOW_W/2) * w;
            sy += (y - LOW_H/2) * w;
            mass += w;
          }
        }
      }

      if (!pointerActive){ // 터치 중이면 무시
        if (mass > MASS_T){
          // 방향 벡터(전면 카메라 거울효과 보정: x 반전)
          let nx = -(sx / mass) / (LOW_W/2);
          let ny =  (sy / mass) / (LOW_H/2);
          // 데드존 & 클램프
          const dead = 0.06;
          nx = Math.abs(nx) < dead ? 0 : nx;
          ny = Math.abs(ny) < dead ? 0 : ny;
          // 타깃으로 반영(스무딩은 rAF에서)
          target.x = clamp1(nx*1.2);   // 감도계수 1.2
          target.y = clamp1(ny*1.2);
        }else{
          // 모션 없으면 천천히 가운데로
          target.x *= 0.985;
          target.y *= 0.985;
        }
      }

      motionRAF = requestAnimationFrame(step);
    };
    motionRAF = requestAnimationFrame(step);
  }

  /* ===== 전체화면 토글 & 더블탭 종료 ===== */
  const inFS = ()=> !!document.fullscreenElement;
  function onFSChange(){
    const fs = inFS();
    fsBtn.textContent = fs ? '전체화면 해제' : '전체화면';
    fsBtn.classList.toggle('hidden', fs);

    if (fs){
      // 전체화면 진입 시 카메라 추적 시도(권한 팝업)
      startCamFollow();
    }else{
      // 전체화면 종료 시 카메라 정지(배터리 절약)
      stopCamFollow();
    }
  }
  fsBtn.addEventListener('click', async ()=>{
    try{
      if(!inFS()) await document.documentElement.requestFullscreen();
      else await document.exitFullscreen();
    }catch(_){}
  });
  document.addEventListener('fullscreenchange', onFSChange);

  // 더블클릭/더블탭으로 전체화면 종료
  addEventListener('dblclick', async ()=>{ if(inFS()) try{ await document.exitFullscreen(); }catch(_){}});

  let lastTap=0; const GAP=300;
  addEventListener('pointerup', async (e)=>{
    // 재미용 깜빡
    eyes.forEach(el=>{
      el.classList.add('blink');
      setTimeout(()=>el.classList.remove('blink'),
        parseFloat(getComputedStyle(root).getPropertyValue('--blink-speed')) + 40);
    });
    if(!inFS()) return;
    const now = e.timeStamp||Date.now();
    if(now-lastTap<=GAP){ try{ await document.exitFullscreen(); }catch(_){} lastTap=0; }
    else lastTap=now;
  });

  // 백그라운드/복귀 처리
  document.addEventListener('visibilitychange', ()=>{
    if (document.hidden) stopCamFollow();
    else if (inFS()) startCamFollow();
  });
})();
</script>
</body>
</html>
