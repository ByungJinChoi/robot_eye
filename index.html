<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Robot Eyes (Stable + KeepAwake)</title>
<style>
  :root{
    --eye-gap: 8vmin;          /* 세로 기준 간격 */
    --eye-size: 42vmin;        /* 세로 기준 크기 */
    --pupil-size: 16vmin;
    --blink-speed: 180ms;
    --bg: #000;
  }
  html, body{
    height:100%; margin:0; background:var(--bg);
    touch-action:none; overscroll-behavior:contain; -webkit-tap-highlight-color:transparent;
  }
  /* 가로: 눈 1.5배, 간격 2배 */
  @media (orientation: landscape){
    :root{
      --eye-size: calc(42vmin * 1.5);
      --pupil-size: calc(16vmin * 1.5);
      --eye-gap: calc(8vmin * 2);
    }
  }

  /* 우상단 전체화면 버튼 */
  #fsBtn{
    position: fixed;
    top: calc(10px + env(safe-area-inset-top));
    right: calc(10px + env(safe-area-inset-right));
    z-index: 10;
    font: 600 14px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    padding: .6rem .9rem; border-radius: 999px;
    border: 1px solid rgba(128,200,255,.6);
    background: rgba(64,160,255,.22); color:#fff;
    backdrop-filter: blur(6px); cursor: pointer;
  }
  #fsBtn.hidden{ display:none; }
  #fsBtn:active{ transform: translateY(1px); }

  /* 좌상단 Wake Lock 상태 배지(선택) */
  #wlStatus{
    position: fixed; top:12px; left:12px; z-index:10;
    font:600 12px system-ui; color:#fff; padding:.35rem .6rem;
    border:1px solid rgba(255,255,255,.3); border-radius:999px;
    background:rgba(0,0,0,.35); backdrop-filter:blur(6px)
  }

  /* 비디오 폴백: 화면 안(좌하단)에 1×1로 존재, 완전히 투명 X(일부 기기에서 off-screen/완전투명 시 스로틀) */
  video#keepAwake{
    position: fixed; left:0; bottom:0; width:1px; height:1px;
    opacity: 0.01; pointer-events:none; z-index:0;
  }

  .face{ height:100%; display:grid; place-items:center; }
  .eyes{ display:grid; grid-auto-flow:column; align-items:center; gap:var(--eye-gap); }
  .eye{
    position:relative; width:var(--eye-size); height:var(--eye-size);
    border-radius:50%; overflow:hidden;
    background: radial-gradient(ellipse at 40% 40%, #fff 0 70%, #e9e9e9 100%);
    box-shadow: 0 1.2vmin 3vmin rgba(0,0,0,.45), inset 0 -0.8vmin 1.6vmin rgba(0,0,0,.12);
  }
  .pupil{
    position:absolute; width:var(--pupil-size); height:var(--pupil-size);
    border-radius:50%; background: radial-gradient(circle at 40% 35%, #222 0 45%, #000 70%, #000 100%);
    left:50%; top:50%; transform:translate(-50%,-50%);
    will-change: transform;
  }
  .shine{
    position:absolute; width: calc(var(--pupil-size)*.35); height: calc(var(--pupil-size)*.35);
    border-radius:50%; background: rgba(255,255,255,.85); left:25%; top:22%; filter: blur(0.2vmin);
  }
  .shine::after{
    content:""; position:absolute; width:55%; height:55%; left:150%; top:130%;
    border-radius:50%; background: rgba(255,255,255,.4); filter: blur(0.25vmin);
  }
  .eyelid{ position:absolute; inset:0; background:var(--bg); transform-origin:top center; transform:scaleY(0); pointer-events:none; }
  .blink .eyelid{ animation: blink var(--blink-speed) ease-in-out forwards; }
  @keyframes blink{ 0%{transform:scaleY(0)} 45%{transform:scaleY(1)} 100%{transform:scaleY(0)} }
</style>
</head>
<body>
  <button id="fsBtn">전체화면</button>
  <div id="wlStatus">WakeLock: init</div>

  <!-- 캔버스 스트림 → 1×1 비디오로 재생(폴백용) -->
  <video id="keepAwake" playsinline muted loop preload="auto"
         controlslist="nodownload nofullscreen noplaybackrate" disablepictureinpicture></video>

  <div class="face" id="face">
    <div class="eyes">
      <div class="eye"><div class="pupil"><div class="shine"></div></div><div class="eyelid"></div></div>
      <div class="eye"><div class="pupil"><div class="shine"></div></div><div class="eyelid"></div></div>
    </div>
  </div>

<script>
(() => {
  const root = document.documentElement;
  const fsBtn = document.getElementById('fsBtn');
  const wlBadge = document.getElementById('wlStatus');
  const eyes = [...document.querySelectorAll('.eye')];
  const pupils = [...document.querySelectorAll('.pupil')];
  const keepAwakeVid = document.getElementById('keepAwake');

  const setBadge = (t)=> wlBadge && (wlBadge.textContent = 'WakeLock: ' + t);

  /* ========== 깜빡임 ========== */
  (function scheduleBlink(){
    const t = 2200 + Math.random()*3300;
    setTimeout(() => {
      eyes.forEach(e => {
        e.classList.add('blink');
        setTimeout(() => e.classList.remove('blink'),
          parseFloat(getComputedStyle(root).getPropertyValue('--blink-speed')) + 40);
      });
      scheduleBlink();
    }, t);
  })();

  /* ========== 입력 스무딩 & 소스 우선순위 ========== */
  // - pointer가 활성화되어 있을 때는 자이로 무시 (충돌/떨림 방지)
  // - rAF 보간(lerp)로 부드럽게 이동
  let target = {x:0, y:0};
  let current = {x:0, y:0};
  const clamp1 = v => Math.max(-1, Math.min(1, v));
  const lerp = (a,b,t)=> a + (b-a)*t;
  function movePupils(nx, ny){
    eyes.forEach((eye, i) => {
      const rect = eye.getBoundingClientRect();
      const rEye = Math.min(rect.width, rect.height)/2;
      const limit = rEye * 0.32;
      const dx = nx * limit, dy = ny * limit;
      const dist = Math.hypot(dx,dy);
      const r = dist>limit ? (limit/dist) : 1;
      pupils[i].style.transform =
        `translate(calc(-50% + ${dx*r}px), calc(-50% + ${dy*r}px))`;
    });
  }
  function tick(){
    // 스무딩 강도: 0.18 (값이 클수록 빠르게 따라감)
    current.x = lerp(current.x, target.x, 0.18);
    current.y = lerp(current.y, target.y, 0.18);
    movePupils(current.x, current.y);
    requestAnimationFrame(tick);
  }
  tick();

  let pointerActive = false;
  let pointerIdleTimer = null;
  function setTarget(nx, ny){ target.x = clamp1(nx); target.y = clamp1(ny); }

  function handlePointer(e){
    const pt = ('touches' in e) ? e.touches[0] : e;
    const cx = innerWidth/2, cy = innerHeight/2;
    const dx = pt.clientX - cx, dy = pt.clientY - cy;
    const d = Math.hypot(innerWidth, innerHeight) || 1;
    setTarget(dx/(d*0.25), dy/(d*0.25));
    pointerActive = true;
    clearTimeout(pointerIdleTimer);
    pointerIdleTimer = setTimeout(()=> { pointerActive = false; }, 1200);
  }
  addEventListener('pointermove', handlePointer, {passive:true});
  addEventListener('pointerdown', handlePointer, {passive:true});

  addEventListener('deviceorientation', e=>{
    if (pointerActive) return; // 포인터 우선
    const {beta, gamma} = e; if (beta==null || gamma==null) return;
    setTarget(gamma/30, beta/30);
  }, true);

  addEventListener('resize', ()=>{ setTarget(0,0); });

  /* ========== Wake Lock + “캔버스 비디오” 폴백 ========== */
  let wakeLock = null;
  let canvas, ctx, stream, rafId = null;

  async function requestWakeLock(){
    try{
      if ('wakeLock' in navigator && !wakeLock){
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener?.('release', ()=>{ wakeLock = null; setBadge('released'); });
        setBadge('active');
        stopVideoFallback();
      }else if(!('wakeLock' in navigator)){
        setBadge('unavailable');
        startVideoFallback();
      }
    }catch(err){
      console.log('WakeLock error:', err);
      setBadge('error');
      startVideoFallback();
      wakeLock = null;
    }
  }
  async function releaseWakeLock(){
    try{ await wakeLock?.release(); }catch(_){}
    finally { wakeLock = null; setBadge('off'); stopVideoFallback(); }
  }

  function startVideoFallback(){
    try{
      if (!('captureStream' in HTMLCanvasElement.prototype)) {
        setBadge('fallback-unsupported');
        return;
      }
      if (!canvas){
        canvas = document.createElement('canvas');
        canvas.width = 2; canvas.height = 2;
        ctx = canvas.getContext('2d');
        stream = canvas.captureStream(1); // 1fps면 충분
        keepAwakeVid.srcObject = stream;
      }
      const pump = ()=>{
        // 프레임이 실제로 발생하도록 1px 토글 그리기
        if(!ctx) return;
        ctx.fillStyle = '#000';
        ctx.fillRect(0,0,2,2);
        rafId = requestAnimationFrame(pump);
      };
      if(!rafId) rafId = requestAnimationFrame(pump);
      keepAwakeVid.play().then(()=> setBadge('video-fallback'))
                         .catch(()=> setBadge('video-fallback(wait)'));
    }catch(e){
      setBadge('fallback-error');
    }
  }
  function stopVideoFallback(){
    if (rafId){ cancelAnimationFrame(rafId); rafId = null; }
    if (keepAwakeVid){
      try{ keepAwakeVid.pause(); keepAwakeVid.removeAttribute('src'); }catch(_){}
      keepAwakeVid.srcObject = null;
    }
    if (stream){
      stream.getTracks().forEach(t=>t.stop());
      stream = null; ctx = null; canvas = null;
    }
  }

  // 앱이 가렸다가(알림/앱전환) 돌아오면 재요청
  document.addEventListener('visibilitychange', ()=>{
    if (!document.hidden && document.fullscreenElement) requestWakeLock();
  });

  /* ========== 전체화면 토글 & 더블탭 종료 ========== */
  const inFS = ()=> !!document.fullscreenElement;
  function onFSChange(){
    const fs = inFS();
    fsBtn.textContent = fs ? '전체화면 해제' : '전체화면';
    fsBtn.classList.toggle('hidden', fs);
    if (fs) requestWakeLock(); else releaseWakeLock();
  }
  fsBtn.addEventListener('click', async ()=>{
    try{
      if(!inFS()) await document.documentElement.requestFullscreen();
      else await document.exitFullscreen();
    }catch(_){}
  });
  document.addEventListener('fullscreenchange', onFSChange);

  // 더블클릭(데스크톱/안드로이드)로 종료
  addEventListener('dblclick', async ()=>{
    if(!inFS()) return;
    try{ await document.exitFullscreen(); }catch(_){}
  });

  // 더블탭 폴백 + 탭마다 깜빡
  let lastTap=0; const GAP=300;
  addEventListener('pointerup', async (e)=>{
    // 깜빡 연출
    eyes.forEach(el=>{
      el.classList.add('blink');
      setTimeout(()=>el.classList.remove('blink'),
        parseFloat(getComputedStyle(root).getPropertyValue('--blink-speed')) + 40);
    });
    if(!inFS()) return;
    const now = e.timeStamp||Date.now();
    if(now-lastTap<=GAP){
      try{ await document.exitFullscreen(); }catch(_){}
      lastTap=0;
    }else{
      lastTap=now;
    }
  });
})();
</script>
</body>
</html>
