<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Robot Eyes (Strong KeepAwake)</title>
<style>
  :root{
    --eye-gap: 8vmin;          /* 세로 기준 간격 */
    --eye-size: 42vmin;        /* 세로 기준 크기 */
    --pupil-size: 16vmin;
    --blink-speed: 180ms;
    --bg: #000;
  }
  html, body{
    height:100%; margin:0; background:var(--bg);
    touch-action:none; overscroll-behavior:contain; -webkit-tap-highlight-color:transparent;
  }
  /* 가로: 눈 1.5배, 간격 2배 */
  @media (orientation: landscape){
    :root{
      --eye-size: calc(42vmin * 1.5);
      --pupil-size: calc(16vmin * 1.5);
      --eye-gap: calc(8vmin * 2);
    }
  }

  /* 우상단 전체화면 버튼 */
  #fsBtn{
    position: fixed;
    top: calc(10px + env(safe-area-inset-top));
    right: calc(10px + env(safe-area-inset-right));
    z-index: 10;
    font: 600 14px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    padding: .6rem .9rem; border-radius: 999px;
    border: 1px solid rgba(128,200,255,.6);
    background: rgba(64,160,255,.22); color:#fff;
    backdrop-filter: blur(6px); cursor: pointer;
  }
  #fsBtn.hidden{ display:none; }
  #fsBtn:active{ transform: translateY(1px); }

  /* 좌상단 상태 배지 */
  #wlStatus{
    position: fixed; top:12px; left:12px; z-index:10;
    font:600 12px system-ui; color:#fff; padding:.35rem .6rem;
    border:1px solid rgba(255,255,255,.3); border-radius:999px;
    background:rgba(0,0,0,.35); backdrop-filter:blur(6px)
  }

  /* 폴백 비디오: 화면 내부(좌하단) 8×8px, 거의 안 보이게 */
  video#keepAwake{
    position: fixed; left:0; bottom:0; width:8px; height:8px;
    opacity: 0.06; pointer-events:none; z-index:0;
  }

  .face{ height:100%; display:grid; place-items:center; }
  .eyes{ display:grid; grid-auto-flow:column; align-items:center; gap:var(--eye-gap); }
  .eye{
    position:relative; width:var(--eye-size); height:var(--eye-size);
    border-radius:50%; overflow:hidden;
    background: radial-gradient(ellipse at 40% 40%, #fff 0 70%, #e9e9e9 100%);
    box-shadow: 0 1.2vmin 3vmin rgba(0,0,0,.45), inset 0 -0.8vmin 1.6vmin rgba(0,0,0,.12);
  }
  .pupil{
    position:absolute; width:var(--pupil-size); height:var(--pupil-size);
    border-radius:50%; background: radial-gradient(circle at 40% 35%, #222 0 45%, #000 70%, #000 100%);
    left:50%; top:50%; transform:translate(-50%,-50%); will-change: transform;
  }
  .shine{
    position:absolute; width: calc(var(--pupil-size)*.35); height: calc(var(--pupil-size)*.35);
    border-radius:50%; background: rgba(255,255,255,.85); left:25%; top:22%; filter: blur(0.2vmin);
  }
  .shine::after{
    content:""; position:absolute; width:55%; height:55%; left:150%; top:130%;
    border-radius:50%; background: rgba(255,255,255,.4); filter: blur(0.25vmin);
  }
  .eyelid{ position:absolute; inset:0; background:var(--bg); transform-origin:top center; transform:scaleY(0); pointer-events:none; }
  .blink .eyelid{ animation: blink var(--blink-speed) ease-in-out forwards; }
  @keyframes blink{ 0%{transform:scaleY(0)} 45%{transform:scaleY(1)} 100%{transform:scaleY(0)} }
</style>
</head>
<body>
  <button id="fsBtn">전체화면</button>
  <div id="wlStatus">WakeLock: init</div>

  <!-- 강한 폴백: 캔버스 스트림 → 8×8 비디오 재생 -->
  <video id="keepAwake" playsinline muted loop preload="auto"
         controlslist="nodownload nofullscreen noplaybackrate" disablepictureinpicture></video>

  <div class="face" id="face">
    <div class="eyes">
      <div class="eye"><div class="pupil"><div class="shine"></div></div><div class="eyelid"></div></div>
      <div class="eye"><div class="pupil"><div class="shine"></div></div><div class="eyelid"></div></div>
    </div>
  </div>

<script>
(() => {
  const root = document.documentElement;
  const fsBtn = document.getElementById('fsBtn');
  const wlBadge = document.getElementById('wlStatus');
  const eyes = [...document.querySelectorAll('.eye')];
  const pupils = [...document.querySelectorAll('.pupil')];
  const keepAwakeVid = document.getElementById('keepAwake');
  const setBadge = (t)=> wlBadge && (wlBadge.textContent = 'WakeLock: ' + t);

  /* ===== 깜빡임 ===== */
  (function scheduleBlink(){
    const t = 2200 + Math.random()*3300;
    setTimeout(() => {
      eyes.forEach(e => {
        e.classList.add('blink');
        setTimeout(() => e.classList.remove('blink'),
          parseFloat(getComputedStyle(root).getPropertyValue('--blink-speed')) + 40);
      });
      scheduleBlink();
    }, t);
  })();

  /* ===== 시선 스무딩 + 포인터 우선 ===== */
  let target = {x:0,y:0}, current = {x:0,y:0};
  const clamp1 = v => Math.max(-1, Math.min(1, v));
  const lerp = (a,b,t)=> a + (b-a)*t;

  function renderPupils(nx, ny){
    eyes.forEach((eye, i) => {
      const rect = eye.getBoundingClientRect();
      const rEye = Math.min(rect.width, rect.height)/2;
      const limit = rEye * 0.32;
      const dx = nx * limit, dy = ny * limit;
      const dist = Math.hypot(dx,dy);
      const r = dist>limit ? (limit/dist) : 1;
      pupils[i].style.transform =
        `translate(calc(-50% + ${dx*r}px), calc(-50% + ${dy*r}px))`;
    });
  }
  function tick(){
    // 스무딩 강도
    current.x = lerp(current.x, target.x, 0.18);
    current.y = lerp(current.y, target.y, 0.18);
    renderPupils(current.x, current.y);
    requestAnimationFrame(tick);
  }
  tick();

  let pointerActive = false;
  let pointerIdleTimer = null;
  function setTarget(nx,ny){ target.x = clamp1(nx); target.y = clamp1(ny); }

  function handlePointer(e){
    const pt = ('touches' in e) ? e.touches[0] : e;
    const cx = innerWidth/2, cy = innerHeight/2;
    const dx = pt.clientX - cx, dy = pt.clientY - cy;
    const d = Math.hypot(innerWidth, innerHeight) || 1;
    setTarget(dx/(d*0.25), dy/(d*0.25));
    pointerActive = true;
    clearTimeout(pointerIdleTimer);
    pointerIdleTimer = setTimeout(()=> { pointerActive = false; }, 1200);
  }
  addEventListener('pointermove', handlePointer, {passive:true});
  addEventListener('pointerdown', handlePointer, {passive:true});

  addEventListener('deviceorientation', e=>{
    if (pointerActive) return;
    const {beta, gamma} = e; if (beta==null || gamma==null) return;
    setTarget(gamma/30, beta/30);
  }, true);

  addEventListener('resize', ()=>{ setTarget(0,0); });

  /* ===== Wake Lock + Watchdog + 강한 비디오 폴백 ===== */
  let wakeLock = null;
  let wlWatchdog = null;

  // 캔버스 스트림 기반 폴백 (실제 프레임이 계속 발생하도록 rAF로 무늬를 바꿈)
  let canvas=null, ctx=null, stream=null, pumpId=null;
  function startVideoFallback(){
    try{
      if (!('captureStream' in HTMLCanvasElement.prototype)) {
        setBadge('fallback-unsupported'); return;
      }
      if (!canvas){
        canvas = document.createElement('canvas');
        canvas.width = 16; canvas.height = 16;
        ctx = canvas.getContext('2d');
        // 프레임레이트 힌트 (일부 브라우저는 무시하지만 설정해둠)
        stream = canvas.captureStream(15);
        keepAwakeVid.srcObject = stream;
      }
      let t=0;
      const pump = ()=>{
        if(!ctx) return;
        // 움직이는 체크 패턴 (정적 프레임으로 최적화되는 것을 방지)
        for(let y=0;y<16;y++){
          for(let x=0;x<16;x++){
            const on = ((x+y+t)%2)===0;
            ctx.fillStyle = on ? '#000' : '#111';
            ctx.fillRect(x,y,1,1);
          }
        }
        t=(t+1)%4;
        pumpId = requestAnimationFrame(pump);
      };
      if(!pumpId) pumpId = requestAnimationFrame(pump);
      keepAwakeVid.play()
        .then(()=> { setBadge('video-fallback'); navigator.mediaSession && (navigator.mediaSession.playbackState='playing'); })
        .catch(()=> { setBadge('video-fallback(wait)'); });
    }catch(e){
      setBadge('fallback-error');
    }
  }
  function stopVideoFallback(){
    if (pumpId){ cancelAnimationFrame(pumpId); pumpId=null; }
    if (stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    if (keepAwakeVid){
      try{ keepAwakeVid.pause(); keepAwakeVid.removeAttribute('src'); }catch(_){}
      keepAwakeVid.srcObject = null;
    }
    canvas = null; ctx = null;
  }

  async function acquireWakeLock(tag=''){
    try{
      if ('wakeLock' in navigator){
        if (!wakeLock || (wakeLock.released ?? false)){
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock.addEventListener?.('release', ()=>{ setBadge('released'); wakeLock=null; });
          setBadge('active');
        }
      }else{
        setBadge('unavailable');
      }
    }catch(err){
      setBadge('error');
      wakeLock = null;
    }
  }
  async function releaseWakeLock(){
    try{ await wakeLock?.release(); }catch(_){}
    finally { wakeLock = null; setBadge('off'); }
  }

  // 페이지가 가려졌다 돌아올 때 재요청
  document.addEventListener('visibilitychange', ()=>{
    if (!document.hidden && document.fullscreenElement){
      acquireWakeLock('visible');
      // 폴백 비디오가 일시정지됐다면 재생
      keepAwakeVid && keepAwakeVid.play().catch(()=>{});
    }
  });

  // 주기적으로 재획득 + 폴백 재생 유지
  function startWatchdog(){
    clearInterval(wlWatchdog);
    wlWatchdog = setInterval(()=>{
      if (!document.fullscreenElement) return;
      acquireWakeLock('watchdog');
      if (keepAwakeVid && keepAwakeVid.paused){
        keepAwakeVid.play().catch(()=>{});
      }
    }, 30000); // 30초 간격
  }
  function stopWatchdog(){
    clearInterval(wlWatchdog); wlWatchdog = null;
  }

  /* ===== 전체화면 토글 & 더블탭 종료 ===== */
  const inFS = ()=> !!document.fullscreenElement;
  function onFSChange(){
    const fs = inFS();
    fsBtn.textContent = fs ? '전체화면 해제' : '전체화면';
    fsBtn.classList.toggle('hidden', fs);

    if (fs){
      acquireWakeLock('enterFS');
      startWatchdog();
      startVideoFallback(); // 웨이크락이 먹더라도 폴백을 함께 켬(더 견고)
    }else{
      stopWatchdog();
      releaseWakeLock();
      stopVideoFallback();
    }
  }
  fsBtn.addEventListener('click', async ()=>{
    try{
      if(!inFS()) await document.documentElement.requestFullscreen();
      else await document.exitFullscreen();
    }catch(_){}
  });
  document.addEventListener('fullscreenchange', onFSChange);

  // 더블클릭(데스크톱/안드)로 종료
  addEventListener('dblclick', async ()=>{
    if(!inFS()) return;
    try{ await document.exitFullscreen(); }catch(_){}
  });

  // 더블탭 폴백 + 탭마다 깜빡
  let lastTap=0; const GAP=300;
  addEventListener('pointerup', async (e)=>{
    // 깜빡 연출
    eyes.forEach(el=>{
      el.classList.add('blink');
      setTimeout(()=>el.classList.remove('blink'),
        parseFloat(getComputedStyle(root).getPropertyValue('--blink-speed')) + 40);
    });
    // 비디오 폴백 재시도(일부 기기는 제스처 뒤에만 재생 허용)
    if (document.fullscreenElement){
      keepAwakeVid && keepAwakeVid.play().catch(()=>{});
    }

    if(!inFS()) return;
    const now = e.timeStamp||Date.now();
    if(now-lastTap<=GAP){
      try{ await document.exitFullscreen(); }catch(_){}
      lastTap=0;
    }else{
      lastTap=now;
    }
  });
})();
</script>
</body>
</html>
